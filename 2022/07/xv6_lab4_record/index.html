<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>[MIT 6.s081] Xv6 Lab4 Traps 实验记录 | tzyt的博客</title><meta name="keywords" content="2022,汇编,底层,栈帧,xv6,UNIX,操作系统,陷入"><meta name="author" content="tzyt"><meta name="copyright" content="tzyt"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="前言：今天是 2022&#x2F;7&#x2F;25 先庆祝一下博客运行 100 天了。 upd@2022&#x2F;9&#x2F;14：最近把实验的代码放到 github 上了，如果需要参考可以查看这里： https:&#x2F;&#x2F;github.com&#x2F;ttzytt&#x2F;xv6-riscv 里面不同的分支就是不同的实验。  Lab4: traps RISC-V assembly 先鸽了  Backtrace   实现一个 backtrace() 的">
<meta property="og:type" content="article">
<meta property="og:title" content="[MIT 6.s081] Xv6 Lab4 Traps 实验记录">
<meta property="og:url" content="https://ttzytt.com/2022/07/xv6_lab4_record/index.html">
<meta property="og:site_name" content="tzyt的博客">
<meta property="og:description" content="前言：今天是 2022&#x2F;7&#x2F;25 先庆祝一下博客运行 100 天了。 upd@2022&#x2F;9&#x2F;14：最近把实验的代码放到 github 上了，如果需要参考可以查看这里： https:&#x2F;&#x2F;github.com&#x2F;ttzytt&#x2F;xv6-riscv 里面不同的分支就是不同的实验。  Lab4: traps RISC-V assembly 先鸽了  Backtrace   实现一个 backtrace() 的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://ttzytt.com/img/xv6/note/xv6%E4%B9%A6%E5%B0%81%E9%9D%A2.png">
<meta property="article:published_time" content="2022-07-25T04:00:00.000Z">
<meta property="article:modified_time" content="2022-10-15T22:48:21.763Z">
<meta property="article:author" content="tzyt">
<meta property="article:tag" content="2022">
<meta property="article:tag" content="汇编">
<meta property="article:tag" content="底层">
<meta property="article:tag" content="栈帧">
<meta property="article:tag" content="xv6">
<meta property="article:tag" content="UNIX">
<meta property="article:tag" content="操作系统">
<meta property="article:tag" content="陷入">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ttzytt.com/img/xv6/note/xv6%E4%B9%A6%E5%B0%81%E9%9D%A2.png"><link rel="shortcut icon" href="/img/avatar.png"><link rel="canonical" href="https://ttzytt.com/2022/07/xv6_lab4_record/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="/css/font.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"8U0W48V3OX","apiKey":"3451307079fbe11a78faea91417af67d","indexName":"hexo","hits":{"per_page":15},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: undefined,
  highlight: {"plugin":"prismjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":700},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '[MIT 6.s081] Xv6 Lab4 Traps 实验记录',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-10-15 18:48:21'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/custom_background.css"><meta name="generator" content="Hexo 6.1.0"><link rel="alternate" href="/atom.xml" title="tzyt的博客" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">41</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">76</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-image"></i><span> 图库</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background: linear-gradient(to right, #2c3e50, #4ca1af)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">tzyt的博客</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-image"></i><span> 图库</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">[MIT 6.s081] Xv6 Lab4 Traps 实验记录</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-07-25T04:00:00.000Z" title="发表于 2022-07-25 00:00:00">2022-07-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-10-15T22:48:21.763Z" title="更新于 2022-10-15 18:48:21">2022-10-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/">实验记录</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">3.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>14分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="[MIT 6.s081] Xv6 Lab4 Traps 实验记录"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>前言：今天是 2022/7/25 先庆祝一下博客运行 100 天了。</p>
<p>upd@2022/9/14：最近把实验的代码放到 github 上了，如果需要参考可以查看这里：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/ttzytt/xv6-riscv">https://github.com/ttzytt/xv6-riscv</a></p>
<p>里面不同的分支就是不同的实验。</p>
<hr>
<h1>Lab4: traps</h1>
<h2 id="RISC-V-assembly">RISC-V assembly</h2>
<p><s>先鸽了</s></p>
<!-- 问： Which registers contain arguments to functions? For example, which register holds 13 in main's call to printf?

答：根据 `call.asm` 中的这一行 -->
<h2 id="Backtrace">Backtrace</h2>
<blockquote>
<p><img src="/img/xv6/lab/lab4_backtrace.png" alt=""><br>
实现一个 <code>backtrace()</code> 的函数，如果某个程序调用了这个函数，该函数应该输出这个程序的 “函数调用顺序”，也就是把当前栈中的函数地址按照先后顺序全部打印出来。</p>
</blockquote>
<p>做这个实验最主要的还是需要了解函数调用的过程，具体可以参考我之前写的<a href="/2022/04/function-call/">这篇文章</a>。</p>
<p>这里我把那篇文章中最重要的图和视频放在下面（<s>绝对不是水字数</s>），如果你之前比较熟悉函数调用的过程，但是现在忘了，看了之后应该比较容易回忆起来。</p>
<blockquote>
<p><img src="/img/%E9%9D%9E%E9%80%92%E5%BD%92dfs/%E6%A0%88%E5%B8%A7%E7%BB%93%E6%9E%84.png" alt=""><br>
<video src='/video/非递归dfs/detail_func_call.mp4' type='video/mp4' controls='controls' width='100%' height='100%'></video></p>
</blockquote>
<p>实验中，我们需要把函数调用的一个 “链条” 打印出来。</p>
<p>比如有下面这个程序：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">third</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token function">backtrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> x<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">int</span> <span class="token function">second</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token function">third</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 假设地址为 114</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">int</span> <span class="token function">first</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> 
    <span class="token keyword">return</span> <span class="token function">second</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 假设地址为 514</span>
<span class="token punctuation">&#125;</span> 

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> test <span class="token operator">=</span> <span class="token function">first</span><span class="token punctuation">(</span><span class="token number">114514</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 假设地址为 1919</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>那么调用 <code>backtrace()</code> 后的正确输出应该是</p>
<pre class="line-numbers language-none"><code class="language-none">114
514
1919<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>其实就是让我们把函数调用者的地址递归的打印下去。</p>
<p>那我们知道，每个栈帧中都储存了当前函数的返回地址。（也就是，这个函数执行好了，应该返回到哪里）。</p>
<p>所以可以直接把每个栈帧中的返回地址打印出来。还应该开一个变量储存当前帧指针的位置，通过这个帧指针加上一些偏移量，获取上一个函数的帧指针，就可以打印上一个函数的返回地址了。</p>
<p>不过要注意的是，在我原来那篇文章中，使用的是 x86 (x64) 架构的处理器，其帧指针的名称为 bp (base pointer) 寄存器，在 riscv 中，fp (frame pointer) 寄存器做了相同的工作。</p>
<p>并且 riscv 中的 fp 指向的位置也和 x86 中的略有不同，具体可以看下面这张图<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="<https://pdos.csail.mit.edu/6.S081/2020/lec/l-riscv.txt>
">[1]</span></a></sup>：</p>
<pre class="line-numbers language-none"><code class="language-none">高地址

Stack
                   .
                   .
      +-&gt;          .
      |   +-----------------+   |
      |   | return address  |   |
      |   |   previous fp ------+
      |   | saved registers |
      |   | local variables |
      |   |       ...       | &lt;-+
      |   +-----------------+   |
      |   | return address  |   |
      +------ previous fp   |   |
          | saved registers |   |
          | local variables |   |
      +-&gt; |       ...       |   |
      |   +-----------------+   |
      |   | return address  |   |
      |   |   previous fp ------+
      |   | saved registers |
      |   | local variables |
      |   |       ...       | &lt;-+
      |   +-----------------+   |
      |   | return address  |   |
      +------ previous fp   |   |
          | saved registers |   |
          | local variables |   |
  $fp --&gt; |       ...       |   | &lt;-- 注意这里!!!
          +-----------------+   |
          | return address  |   |  
          |   previous fp ------+ &lt;-- 如果是 x86，那么 bp 指针会指向这里
          | saved registers |
  $sp --&gt; | local variables |
          +-----------------+

低地址（增长方向）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以发现，在 riscv 中，fp 指向的是当前栈帧返回地址前面的一个位置（地址更高）。但是在 x86 中，bp 指向的是前一个栈帧的 bp 寄存器。</p>
<p>这个大概是因为 x86 和 riscv 对于一个栈帧定义的不同。在 riscv 的定义中，返回地址也是属于当前栈帧的的一部分（说实话我觉得这个设计更合理）。</p>
<p>虽然我们总是可以通过 fp 获得函数的返回地址，但是还需要获得到当前的 fp，这就需要用到 c 语言的内嵌汇编了，我们可以把这个函数放到 <code>kernel/riscv.h</code> 里：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">inline</span> uint64
<span class="token function">r_fp</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
  uint64 x<span class="token punctuation">;</span>
  <span class="token keyword">asm</span> <span class="token keyword">volatile</span><span class="token punctuation">(</span><span class="token string">"mv %0, s0"</span> <span class="token operator">:</span> <span class="token string">"=r"</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> x<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>GCC 拓展内联汇编的基本格式是：</p>
<pre class="line-numbers language-none"><code class="language-none">asm asm-qualifiers ( AssemblerTemplate 
                 : OutputOperands 
                 [ : InputOperands
                 [ : Clobbers ] ])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中，asm 代表着内联汇编的开始，asm-qualifiers 表示这个内联汇编的一些性质，比如我们这里加了 volatile 就表示不希望 GCC 把这个汇编优化掉。</p>
<p>在上面的 <code>(&quot;mv %0, s0&quot; : &quot;=r&quot; (x) )</code> 中，<code>mv %0, s0</code> 是一个汇编的模板，并不是真正的汇编，有点类似于 C++ 中的模板，在编译的时候会把类型替换掉。GCC 编译的时候也会把 <code>%0</code> 这个东西替换成后面 <code>: &quot;=r&quot; (x)</code> 规定的变量（这里是 x）所在的寄存器。</p>
<p>而这个 <code>&quot;=r&quot;</code> 代表了一种限制条件，里面的 <code>r</code> 表示这个 x 变量可以在任何的通用寄存器中，而等于号表明该变量是被写入的。</p>
<p>除了 <code>r</code>，还有很多种限制条件<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="<https://gcc.gnu.org/onlinedocs/gcc/Simple-Constraints.html#Simple-Constraints>
">[2]</span></a></sup>，比如 m 代表了该变量可以储存在内存中。如果你还想了解更多的限制条件，可以参考 <a target="_blank" rel="noopener" href="https://gcc.gnu.org/onlinedocs/gcc/Simple-Constraints.html#Simple-Constraints">GCC 的文档</a>。</p>
<p><a target="_blank" rel="noopener" href="https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html#Extended-Asm">GCC 的文档</a>中对拓展内联汇编也有非常详细的解释。</p>
<p>所以，总的来说，<code>r_fp()</code> 这个函数读出了 <code>s0</code> 这个寄存器的值，然后储存在 <code>x</code> 中，最后又把 <code>x</code> 返回了。</p>
<p>但是我们要读取的明明是 fp 这个寄存器，为什么这个函数里写的是 <code>s0</code> 呢，具体可以看看下面这个表<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="<https://pdos.csail.mit.edu/6.828/2021/readings/riscv-calling.pdf>">[3]</span></a></sup>：</p>
<div align=center width=70%>
    <img width=70% src=/img/xv6/lab/riscv_calling.png >
</div>
<p>在 ABI Name 那一列，可以看到 s0 其实就是 fp 的别名。</p>
<p>有了这些知识，就可以写出 <code>backtrace()</code> 这个函数了：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> 
<span class="token function">backtrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"in bt\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 帧指针下面的是返回地址</span>
  <span class="token comment">// 再下面一个是上一个栈帧的帧指针</span>
  uint64<span class="token operator">*</span> cur_frame <span class="token operator">=</span> <span class="token punctuation">(</span>uint64 <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">r_fp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  uint64<span class="token operator">*</span> top <span class="token operator">=</span> <span class="token function">PGROUNDUP</span><span class="token punctuation">(</span><span class="token punctuation">(</span>uint64<span class="token punctuation">)</span>cur_frame<span class="token punctuation">)</span><span class="token punctuation">;</span>
  uint64<span class="token operator">*</span> bot <span class="token operator">=</span> <span class="token function">PGROUNDDOWN</span><span class="token punctuation">(</span><span class="token punctuation">(</span>uint64<span class="token punctuation">)</span>cur_frame<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">while</span><span class="token punctuation">(</span>cur_frame <span class="token operator">&lt;</span> top <span class="token operator">&amp;&amp;</span> cur_frame <span class="token operator">></span> bot<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p\n"</span><span class="token punctuation">,</span> cur_frame<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 先打印当前的返回地址</span>
    cur_frame <span class="token operator">=</span> cur_frame<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 然后把当前栈帧变成上一个栈帧</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看到这里用了一些很奇怪的写法，好像是负数下标的数字，其实这个 <code>cur_frame[-1]</code> 等价于 <code>*(cur_frame - 1)</code>。并且，因为这里 <code>cur_frame</code> 是六十四位的指针，所以 <code>*(cur_frame - 1)</code> 是读取 <code>cur_frame</code> 前八个字节位置的数据。</p>
<p>这里使用 <code>PGROUNDDOWN</code> 和 <code>PGROUNDUP</code> 是因为，一连串的函数调用最多放在一个页中。那么如果我们在递归打印的时候，超出了这一页的范围，就可以说明已经是最底层的函数，可以停止了。</p>
<p>最后我们按照要求在 <code>sys_sleep()</code> 这个系统调用里添加一下 <code>backtrace()</code>，就完成这个 lab 了。</p>
<h2 id="Alarm">Alarm</h2>
<blockquote>
<p><img src="/img/xv6/lab/lab4_alarm.png" alt=""><br>
实现一个 <code>sigalarm(interval, handler)</code> 的系统调用。及每过 interval 个时钟周期，就执行一遍 handler 这个函数。此外还要实现一个 <code>sigreturn()</code> 系统调用，如果 handler 调用了这个系统调用，就应该停止执行 handler 这个函数，然后恢复正常的执行顺序。如果说 <code>sigalarm</code> 的两个参数都为 0，就代表停止执行 handler 函数。</p>
</blockquote>
<p>其实理解这个 lab 还是挺难的，特别是 <code>sigreturn</code>，具体可以看看 <code>alarmtest.c</code> 这个程序，然后就是，需要对陷入的过程有比较好的理解，如果不熟悉，可以看看我的<a href="/2022/07/xv6_note/">这篇文章</a>：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span>
<span class="token function">periodic</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
  count <span class="token operator">=</span> count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"alarm!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">sigreturn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// tests whether the kernel calls</span>
<span class="token comment">// the alarm handler even a single time.</span>
<span class="token keyword">void</span>
<span class="token function">test0</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
  <span class="token keyword">int</span> i<span class="token punctuation">;</span>
  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"test0 start\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token function">sigalarm</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> periodic<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token operator">*</span><span class="token number">500000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>i <span class="token operator">%</span> <span class="token number">1000000</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
      <span class="token function">write</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"."</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>count <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>
      <span class="token keyword">break</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  <span class="token function">sigalarm</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>count <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"test0 passed\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\ntest0 failed: the kernel never called the alarm handler\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这个 <code>sigreturn</code> 的意思就是，我们本来可能在执行这个 for 循环中的代码，然后突然开始执行 <code>periodic()</code> 这个函数（因为时间到了）。如果在 <code>periodic()</code> 函数中调用了 <code>sigreturn()</code>。就应该停止执行 <code>periodic()</code> 里的东西，然后回到 for 循环中执行。（可以看这个 <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1wu411d7Kd/?spm_id_from=333.788&amp;vd_source=4de003ee9a3815aedd7d0cb2c7a12d14">up 主</a>讲的，比较清晰）</p>
<p>这里我们可以依次查看 <code>alarmtest.c</code> 中的几个 test（或者说就是测试点），然后按照这些测试点的要求去实现这个系统调用。</p>
<h3 id="test0-invoke-handler">test0: invoke handler</h3>
<blockquote>
<p>Get started by modifying the kernel to jump to the alarm handler in user space, which will cause test0 to print “alarm!”. Don’t worry yet what happens after the “alarm!” output; it’s OK for now if your program crashes after printing “alarm!”. Here are some hints:</p>
</blockquote>
<p>大概就是说，我们可以先尝试去正确的跳转到<strong>用户态</strong>去执行 handler 函数（为了保持隔离性，不能在内核里直接把这个函数执行了），如果跳转之后报错了也没关系。</p>
<p>首先可以回忆下 xv6 发生陷入的过程，我们是根据 epc 这个寄存器来判断陷入之后返回的地址的。如果直接改变了 epc 的地址，就可以在返回的之后跳转到 handler 的地址。</p>
<p>那如何判断时候到了要跳转的时间呢？</p>
<p>riscv 的硬件（其实我不太确定是哪个硬件）会每过一个时钟周期都产生一个时钟中断，而 <code>trap.c</code> 会处理这个中断。</p>
<p>我们可以依靠这个中断出现的次数去判断是否应该跳转，如果需要，就直接在 <code>trap.c</code> 中把 trapframe 里 epc 的值改了（改成 handler 的）。</p>
<p>因此需要在 <code>struct proc</code> 给每个进程加入如下的属性：</p>
<ul>
<li><code>uint64 alarm_tks;</code> 用于记录执行 handler 的间隔，如果为 0 代表不执行</li>
<li><code>void (*alarm_handler)();</code> handler 的地址</li>
<li><code>uint64 alarm_tk_elapsed;</code> 距离上次执行 handler 过去的时间</li>
</ul>
<p>并且在 <code>sys_sigalarm()</code> 把获取到的这些参数存入这些属性中，对于 <code>sys_sigreturn()</code>，我们先不做任何操作，直接返回一个 0：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">uint64 
<span class="token function">sys_sigalarm</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
  <span class="token keyword">int</span> ticks<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">proc</span><span class="token operator">*</span> p <span class="token operator">=</span> <span class="token function">myproc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  uint64 handler<span class="token punctuation">;</span>
  <span class="token function">try</span><span class="token punctuation">(</span><span class="token function">argint</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>ticks<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">try</span><span class="token punctuation">(</span><span class="token function">argaddr</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>handler<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  p<span class="token operator">-></span>alarm_tks <span class="token operator">=</span> ticks<span class="token punctuation">;</span>
  p<span class="token operator">-></span>alarm_handler <span class="token operator">=</span> handler<span class="token punctuation">;</span>
  p<span class="token operator">-></span>alarm_tk_elapsed <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>相应的，我们创建了这些属性，就需要在进程的初始化函数 <code>allocporc()</code> 和释放函数 <code>freeproc()</code> 中做相应的初始化和释放。</p>
<p>首先是 <code>allocporc()</code> 的改动：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">……
  p<span class="token operator">-></span>alarm_tk_elapsed <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  p<span class="token operator">-></span>alarm_state <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  p<span class="token operator">-></span>alarm_tks <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> p<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>然后是 <code>freeproc()</code>：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">……
  p<span class="token operator">-></span>alarm_handler <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  p<span class="token operator">-></span>alarm_tk_elapsed <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  p<span class="token operator">-></span>alarm_tks <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>接下来就可以在 <code>trap.c</code> 的 <code>usertrap()</code> 中函数实现跳转了：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">……
  <span class="token keyword">if</span><span class="token punctuation">(</span>which_dev <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">// 时钟中断的编号为 2</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">-></span>alarm_tks <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> 
      p<span class="token operator">-></span>alarm_tk_elapsed<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">// 距离上次执行 handler 经过的时间</span>
      <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">-></span>alarm_tk_elapsed <span class="token operator">></span> p<span class="token operator">-></span>alarm_tks<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">// 如果超过了规定的时间</span>
        p<span class="token operator">-></span>alarm_tk_elapsed <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        p<span class="token operator">-></span>trapframe<span class="token operator">-></span>epc <span class="token operator">=</span> p<span class="token operator">-></span>alarm_handler<span class="token punctuation">;</span> <span class="token comment">// 直接改 epc，这样回用户态的时候就会执行地址为 epc 的指令</span>
      <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这样我们就能顺利的跳转到 handler，并且通过 test0，当然也毫无悬念的报错了。</p>
<p>报错的主要原因是还没实现 <code>sys_sigreturn()</code>，这样在执行完 handler 函数之后就不知道返回哪里了。</p>
<p>而要通过 test1 和 test2 就必须解决这个问题：</p>
<h3 id="test1-test2-resume-interrupted-code">test1/test2(): resume interrupted code</h3>
<blockquote>
<p>Chances are that alarmtest crashes in test0 or test1 after it prints “alarm!”, or that alarmtest (eventually) prints “test1 failed”, or that alarmtest exits without printing “test1 passed”. To fix this, you must ensure that, when the alarm handler is done, control returns to the instruction at which the user program was originally interrupted by the timer interrupt. You must ensure that the register contents are restored to the values they held at the time of the interrupt, so that the user program can continue undisturbed after the alarm. Finally, you should “re-arm” the alarm counter after each time it goes off, so that the handler is called periodically.</p>
</blockquote>
<p>大概的意思是，我们需要在执行完 handler 后返回到正确的位置。</p>
<p>需要注意的是，我们跳转到内核去响应陷入和系统调用时，寄存器的值是会改变的，这样就算通过改变 epc 的值回到了正确的位置，也不能正确的执行（没有把寄存器的环境备份下来）。</p>
<p>因此我们在 <code>struct proc</code> 再加一个 <code>struct trapframe</code> 类的属性，用于备份执行 handler 前的环境：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">……
<span class="token keyword">struct</span> <span class="token class-name">trapframe</span> <span class="token operator">*</span>trapframe<span class="token punctuation">;</span> <span class="token comment">// data page for trampoline.S</span>
<span class="token keyword">struct</span> <span class="token class-name">trapframe</span> <span class="token operator">*</span>alarmframe<span class="token punctuation">;</span> <span class="token comment">// 新增的备份 trapframe</span>
……<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>当然，在 <code>allocproc()</code> 和 <code>freeproc()</code> 中的初始化和释放也是少不了的：</p>
<p><code>allocproc()</code>：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">……
<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>p<span class="token operator">-></span>alarmframe <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">trapframe</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">kalloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
  <span class="token function">freeproc</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token operator">-></span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
……<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>freeproc()</code>：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">-></span>alarmframe<span class="token punctuation">)</span>
  <span class="token function">kfree</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span>p<span class="token operator">-></span>alarmframe<span class="token punctuation">)</span><span class="token punctuation">;</span>
p<span class="token operator">-></span>alarmframe <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><code>alarmframe</code> 可以在 <code>trap.c</code> 里的 <code>usertrap()</code> 获取，也就是需要执行 handler 的时候，我们先备份一下环境，然后再执行：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span><span class="token punctuation">(</span>which_dev <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">-></span>alarm_tks <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    p<span class="token operator">-></span>alarm_tk_elapsed<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">-></span>alarm_tk_elapsed <span class="token operator">></span> p<span class="token operator">-></span>alarm_tks<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
      p<span class="token operator">-></span>alarm_tk_elapsed <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
      <span class="token operator">*</span>p<span class="token operator">-></span>alarmframe <span class="token operator">=</span> <span class="token operator">*</span>p<span class="token operator">-></span>trapframe<span class="token punctuation">;</span> <span class="token comment">// 注意这里</span>
      p<span class="token operator">-></span>trapframe<span class="token operator">-></span>epc <span class="token operator">=</span> p<span class="token operator">-></span>alarm_handler<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
  <span class="token punctuation">&#125;</span>
  <span class="token function">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 <code>sys_sigreturn()</code> 里面，我们应该去按照 <code>alarmframe</code> 恢复 <code>trapframe</code>，这样包括 epc 在内的所有通用寄存器都会被恢复，自然也就会跳出 handler，按照原来的顺序执行程序了：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">uint64
<span class="token function">sys_sigreturn</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
  <span class="token keyword">struct</span> <span class="token class-name">proc</span><span class="token operator">*</span> p <span class="token operator">=</span> <span class="token function">myproc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token operator">*</span>p<span class="token operator">-></span>trapframe <span class="token operator">=</span> <span class="token operator">*</span>p<span class="token operator">-></span>alarmframe<span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>到这里，我们再去运行 alarmtest，会发现还是不能完全过。</p>
<p>试想这样一个情况，如果 handler 执行的特别慢，自从上次调用 handler 已经过去了规定的时钟周期，但是 handler 还没执行好，这个时候我们又去改一遍 epc，这个 handler 又从头开始执行了，那着不就出大问题了，因为我们每次都会去改 epc，然后就永远执行不完 handler 了。</p>
<p>测试程序里就包括了这个情况：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span>
<span class="token function">slow_handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
  count<span class="token operator">++</span><span class="token punctuation">;</span>
  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"alarm!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"test2 failed: alarm handler called more than once\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token operator">*</span><span class="token number">500000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 超慢的 handler</span>
    <span class="token keyword">asm</span> <span class="token keyword">volatile</span><span class="token punctuation">(</span><span class="token string">"nop"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// avoid compiler optimizing away loop</span>
  <span class="token punctuation">&#125;</span>
  <span class="token function">sigalarm</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">sigreturn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>所以我们需要在 <code>struct proc</code> 里再加一个属性，就是 <code>alarm_state</code>。如果这个属性为 1，就表示，handler 程序正在执行，这个时候就算又过了 tick 个时钟周期，我们也不能去改 epc 让 handler 重复执行。</p>
<p>因为新添加了一个属性，所以 <code>allocproc</code> 和 <code>freeproc</code> 也需要改，这里就不细讲了。</p>
<p>更重要的还是要更改 <code>usertrap()</code> 函数中的东西：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span><span class="token punctuation">(</span>which_dev <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">-></span>alarm_tks <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    p<span class="token operator">-></span>alarm_tk_elapsed<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">-></span>alarm_tk_elapsed <span class="token operator">></span> p<span class="token operator">-></span>alarm_tks <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>p<span class="token operator">-></span>alarm_state<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">// 注意这里必须是 p->alarm_state 为 0</span>
      p<span class="token operator">-></span>alarm_tk_elapsed <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
      <span class="token operator">*</span>p<span class="token operator">-></span>alarmframe <span class="token operator">=</span> <span class="token operator">*</span>p<span class="token operator">-></span>trapframe<span class="token punctuation">;</span>
      p<span class="token operator">-></span>trapframe<span class="token operator">-></span>epc <span class="token operator">=</span> p<span class="token operator">-></span>alarm_handler<span class="token punctuation">;</span>
      p<span class="token operator">-></span>alarm_state <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 注意这里：改了 epc 就代表开始执行了</span>
    <span class="token punctuation">&#125;</span>
  <span class="token punctuation">&#125;</span>
  
  <span class="token function">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>同时，<code>sys_sigreturn()</code> 函数里的东西也要改，因为调用了这个函数就代表 handler 不再执行了：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">uint64
<span class="token function">sys_sigreturn</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
  <span class="token keyword">struct</span> <span class="token class-name">proc</span><span class="token operator">*</span> p <span class="token operator">=</span> <span class="token function">myproc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token operator">*</span>p<span class="token operator">-></span>trapframe <span class="token operator">=</span> <span class="token operator">*</span>p<span class="token operator">-></span>alarmframe<span class="token punctuation">;</span>
  p<span class="token operator">-></span>alarm_state <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 更改 alarm_state 的值为 0，代表 handler 停止执行</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>改完之后就能成功 AC 了，也祝现在做这个实验的人尽快 AC：</p>
<p><img src="/img/xv6/lab/lab4_AC.png" alt=""></p>
<h2 id="总结-4">总结</h2>
<p>比起这里的实验，其实更重要的还是理解 xv6 中陷入的过程，就算没有完全理解陷入过程，也能一步一步的照着实验指导做出这些实验。当然，要理解这里的陷入机制也属实是令人头疼，毕竟有很多以前从来没接触过的 riscv 汇编和底层的知识。虽然难理解，但理解和完成实验后，会让人不由自主的感叹操作系统设计的巧妙。</p>
<p>做完这个实验后，以前很多对操作系统的疑问也解决了，比如像 alarm 实验的原理。同时，也发现自己对汇编的理解还很浅。具体可以看 xv6 笔记<a href="/2022/07/xv6_note">那篇文章</a>，一直理解不了为什么 <code>userret</code> 和 <code>uservec</code> 里要交换 <code>sscratch</code> 寄存器，后来问了才知道这个是特权级寄存器，不能用 ld，和 sd 这样的指令操作（实际上现在也没理解这样设计的原因）。</p>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.S081/2020/lec/l-riscv.txt">https://pdos.csail.mit.edu/6.S081/2020/lec/l-riscv.txt</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a target="_blank" rel="noopener" href="https://gcc.gnu.org/onlinedocs/gcc/Simple-Constraints.html#Simple-Constraints">https://gcc.gnu.org/onlinedocs/gcc/Simple-Constraints.html#Simple-Constraints</a><a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2021/readings/riscv-calling.pdf">https://pdos.csail.mit.edu/6.828/2021/readings/riscv-calling.pdf</a><a href="#fnref:3" rev="footnote"> ↩</a></span></li></ol></div></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">tzyt</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://ttzytt.com/2022/07/xv6_lab4_record/">https://ttzytt.com/2022/07/xv6_lab4_record/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://ttzytt.com" target="_blank">tzyt的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/2022/">2022</a><a class="post-meta__tags" href="/tags/%E6%B1%87%E7%BC%96/">汇编</a><a class="post-meta__tags" href="/tags/%E5%BA%95%E5%B1%82/">底层</a><a class="post-meta__tags" href="/tags/%E6%A0%88%E5%B8%A7/">栈帧</a><a class="post-meta__tags" href="/tags/xv6/">xv6</a><a class="post-meta__tags" href="/tags/UNIX/">UNIX</a><a class="post-meta__tags" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><a class="post-meta__tags" href="/tags/%E9%99%B7%E5%85%A5/">陷入</a></div><div class="post_share"><div class="social-share" data-image="/img/xv6/note/xv6%E4%B9%A6%E5%B0%81%E9%9D%A2.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/07/xv6_lab5_record/"><img class="prev-cover" src="/img/xv6/note/xv6%E4%B9%A6%E5%B0%81%E9%9D%A2.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">[MIT 6.s081] Xv6 Lab5 (2020) Lazy Page Allocation 实验记录</div></div></a></div><div class="next-post pull-right"><a href="/2022/07/CC_STARTERS_48/"><img class="next-cover" src="/img/Codechef_logo.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">CC (Codechef) STARTERS 48 题解</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/07/xv6_lab2_record/" title="[MIT 6.s081] Xv6 Lab2 System Calls 实验记录"><img class="cover" src="/img/xv6/note/xv6%E4%B9%A6%E5%B0%81%E9%9D%A2.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-10</div><div class="title">[MIT 6.s081] Xv6 Lab2 System Calls 实验记录</div></div></a></div><div><a href="/2022/07/xv6_lab3_record/" title="[MIT 6.s081] Xv6 Lab3 (2021) Page Tables 实验记录"><img class="cover" src="/img/xv6/note/xv6%E4%B9%A6%E5%B0%81%E9%9D%A2.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-14</div><div class="title">[MIT 6.s081] Xv6 Lab3 (2021) Page Tables 实验记录</div></div></a></div><div><a href="/2022/04/function-call/" title="浅谈函数调用的实现"><img class="cover" src="/img/%E9%9D%9E%E9%80%92%E5%BD%92dfs/cover.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-20</div><div class="title">浅谈函数调用的实现</div></div></a></div><div><a href="/2022/08/xv6_lab10_record/" title="[MIT 6.s081] Xv6 Lab10 File System 实验记录"><img class="cover" src="/img/xv6/note/xv6%E4%B9%A6%E5%B0%81%E9%9D%A2.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-08-18</div><div class="title">[MIT 6.s081] Xv6 Lab10 File System 实验记录</div></div></a></div><div><a href="/2022/08/xv6_lab11_record/" title="[MIT 6.s081] Xv6 Lab11 Mmap 实验记录"><img class="cover" src="/img/xv6/note/xv6%E4%B9%A6%E5%B0%81%E9%9D%A2.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-08-21</div><div class="title">[MIT 6.s081] Xv6 Lab11 Mmap 实验记录</div></div></a></div><div><a href="/2022/07/xv6_lab1_record/" title="[MIT 6.s081] Xv6 Lab1 Util 实验记录"><img class="cover" src="/img/xv6/lab/lab1_primes_pipeline_transfer.svg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-09</div><div class="title">[MIT 6.s081] Xv6 Lab1 Util 实验记录</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Giscus</span><span class="switch-btn"></span><span class="second-comment">Waline</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div><div><div id="waline-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">tzyt</div><div class="author-info__description"></div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">41</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">76</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://www.luogu.com.cn/user/394488"><i class="fa-solid fa-up-right-from-square"></i><span>洛谷</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/ttzytt" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="/Zyt2006613@outlook.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS链接"><i class="fa fa-rss"></i></a><a class="social-icon" href="https://stackoverflow.com/users/20080946/ttzytt?tab=profile" target="_blank" title="stack overflow"><i class="fa-brands fa-stack-overflow"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">如果有想交换友链的，可以通过洛谷的私信，我的邮箱，或者是右下角那个聊天室联系我。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">Lab4: traps</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#RISC-V-assembly"><span class="toc-text">RISC-V assembly</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Backtrace"><span class="toc-text">Backtrace</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Alarm"><span class="toc-text">Alarm</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#test0-invoke-handler"><span class="toc-text">test0: invoke handler</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#test1-test2-resume-interrupted-code"><span class="toc-text">test1&#x2F;test2(): resume interrupted code</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-4"><span class="toc-text">总结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/12/CS144_lab0-3_rec/" title="[Stanford CS144] Lab0-Lab3 实验记录"><img src="/img/CS144/sponge%E7%BB%93%E6%9E%84%E5%9B%BE.svg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="[Stanford CS144] Lab0-Lab3 实验记录"/></a><div class="content"><a class="title" href="/2022/12/CS144_lab0-3_rec/" title="[Stanford CS144] Lab0-Lab3 实验记录">[Stanford CS144] Lab0-Lab3 实验记录</a><time datetime="2022-12-21T05:00:00.000Z" title="发表于 2022-12-21 00:00:00">2022-12-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/12/CF1774C/" title="CF1774C 题解"><img src="/img/Codeforces_logo.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CF1774C 题解"/></a><div class="content"><a class="title" href="/2022/12/CF1774C/" title="CF1774C 题解">CF1774C 题解</a><time datetime="2022-12-18T03:33:18.821Z" title="发表于 2022-12-17 22:33:18">2022-12-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/dense_neu_net_nmist/" title="反向传播（Backpropagation）算法学习笔记，基于全连接神经网络"><img src="/img/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/bp/mnist_number.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="反向传播（Backpropagation）算法学习笔记，基于全连接神经网络"/></a><div class="content"><a class="title" href="/2022/10/dense_neu_net_nmist/" title="反向传播（Backpropagation）算法学习笔记，基于全连接神经网络">反向传播（Backpropagation）算法学习笔记，基于全连接神经网络</a><time datetime="2022-10-31T04:00:00.000Z" title="发表于 2022-10-31 00:00:00">2022-10-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/RTNW_note1/" title="Ray Tracing : The Next Week 学习笔记（1）"><img src="/img/%E5%85%89%E8%BF%BD/next_week/final_scene.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Ray Tracing : The Next Week 学习笔记（1）"/></a><div class="content"><a class="title" href="/2022/10/RTNW_note1/" title="Ray Tracing : The Next Week 学习笔记（1）">Ray Tracing : The Next Week 学习笔记（1）</a><time datetime="2022-10-20T04:00:00.000Z" title="发表于 2022-10-20 00:00:00">2022-10-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/09/RTOW_note2/" title="Ray Tracing in One Weekend 学习笔记（2）：相机类的实现"><img src="/img/%E5%85%89%E8%BF%BD/one_weekend/rand_scene.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Ray Tracing in One Weekend 学习笔记（2）：相机类的实现"/></a><div class="content"><a class="title" href="/2022/09/RTOW_note2/" title="Ray Tracing in One Weekend 学习笔记（2）：相机类的实现">Ray Tracing in One Weekend 学习笔记（2）：相机类的实现</a><time datetime="2022-09-06T04:00:00.000Z" title="发表于 2022-09-06 00:00:00">2022-09-06</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 By tzyt</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Algolia</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/contrib/copy-tex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/contrib/copy-tex.css"><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script><script>function loadGiscus () {
  let nowTheme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'light'

  const config = Object.assign({
    src: 'https://giscus.app/client.js',
    'data-repo': 'ttzytt/ttzytt.github.io',
    'data-repo-id': 'R_kgDOHL2ORg',
    'data-category-id': 'DIC_kwDOHL2ORs4CQ-4Q',
    'data-mapping': 'pathname',
    'data-theme': nowTheme,
    'data-reactions-enabled': '1',
    crossorigin: 'anonymous',
    async: true
  },null)

  let ele = document.createElement('script')
  for (let key in config) {
    ele.setAttribute(key, config[key])
  }
  document.getElementById('giscus-wrap').insertAdjacentElement('afterbegin',ele)
}

function changeGiscusTheme () {
  const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'light'

  function sendMessage(message) {
    const iframe = document.querySelector('iframe.giscus-frame');
    if (!iframe) return;
    iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
  }

  sendMessage({
    setConfig: {
      theme: theme
    }
  });
}

if ('Giscus' === 'Giscus' || !false) {
  if (false) btf.loadComment(document.getElementById('giscus-wrap'), loadGiscus)
  else loadGiscus()
} else {
  function loadOtherComment () {
    loadGiscus()
  }
}</script><script>function loadWaline () {
  function initWaline () {
    const waline = new Waline(Object.assign({
      el: '#waline-wrap',
      serverURL: 'https://waline-comment-for-hexo-blog-pi6qofxob-ttzytt.vercel.app/',
      path: location.pathname,
      visitor: true,
      dark: 'html[data-theme="dark"]'
    }, null))
  }

  if (typeof Waline === 'function') initWaline()
  else getScript('https://cdn.jsdelivr.net/npm/@waline/client/dist/Waline.min.js').then(initWaline)
}

if ('Giscus' === 'Waline' || !false) {
  if (false) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
  else setTimeout(loadWaline, 0)
} else {
  function loadOtherComment () {
    loadWaline()
  }
}</script></div><script src="/js/gitter_chat.js"></script><script src="https://sidecar.gitter.im/dist/sidecar.v1.js" async defer></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="100,100,100" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>