<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>浅谈函数调用的实现 | tzyt的博客</title><meta name="keywords" content="2022,汇编,底层,栈帧,dfs,整活"><meta name="author" content="tzyt"><meta name="copyright" content="tzyt"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="前言：前几天看了一集南京大学蒋炎岩老师的操作系统课程，属于是跪着看完的，真的太强了。先不说讲的非常好，里面的非递归汉诺塔（可以在课程网站中找到）就让我对递归和函数调用有了新的理解，并且让我对函数调用的原理有了一些兴趣。所以我决定去详细的了解函数调用的原理，并且写一个类似非递归汉诺塔的东西，比如非递归的 dfs（这部分属于是整活了，非递归的 dfs 并没有显著的性能提升，如果你想把它用在 OI 中那">
<meta property="og:type" content="article">
<meta property="og:title" content="浅谈函数调用的实现">
<meta property="og:url" content="https://ttzytt.com/2022/04/function-call/index.html">
<meta property="og:site_name" content="tzyt的博客">
<meta property="og:description" content="前言：前几天看了一集南京大学蒋炎岩老师的操作系统课程，属于是跪着看完的，真的太强了。先不说讲的非常好，里面的非递归汉诺塔（可以在课程网站中找到）就让我对递归和函数调用有了新的理解，并且让我对函数调用的原理有了一些兴趣。所以我决定去详细的了解函数调用的原理，并且写一个类似非递归汉诺塔的东西，比如非递归的 dfs（这部分属于是整活了，非递归的 dfs 并没有显著的性能提升，如果你想把它用在 OI 中那">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://ttzytt.com/img/%E9%9D%9E%E9%80%92%E5%BD%92dfs/cover.png">
<meta property="article:published_time" content="2022-04-21T03:53:01.966Z">
<meta property="article:modified_time" content="2022-06-17T03:55:46.409Z">
<meta property="article:author" content="tzyt">
<meta property="article:tag" content="2022">
<meta property="article:tag" content="汇编">
<meta property="article:tag" content="底层">
<meta property="article:tag" content="栈帧">
<meta property="article:tag" content="dfs">
<meta property="article:tag" content="整活">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ttzytt.com/img/%E9%9D%9E%E9%80%92%E5%BD%92dfs/cover.png"><link rel="shortcut icon" href="/img/avatar.gif"><link rel="canonical" href="https://ttzytt.com/2022/04/function-call/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="/css/font.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"8U0W48V3OX","apiKey":"3451307079fbe11a78faea91417af67d","indexName":"hexo","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: undefined,
  highlight: {"plugin":"prismjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '浅谈函数调用的实现',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-06-16 23:55:46'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/custom_background.css"><meta name="generator" content="Hexo 6.1.0"><link rel="alternate" href="/atom.xml" title="tzyt的博客" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.gif" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">13</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">35</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-image"></i><span> 图库</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background: linear-gradient(to right, #2c3e50, #4ca1af)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">tzyt的博客</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-image"></i><span> 图库</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">浅谈函数调用的实现</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-04-21T03:53:01.966Z" title="发表于 2022-04-20 23:53:01">2022-04-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-06-17T03:55:46.409Z" title="更新于 2022-06-16 23:55:46">2022-06-16</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%B1%87%E7%BC%96/">汇编</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">11.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>39分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="浅谈函数调用的实现"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2022/04/function-call/#post-comment"><span class="waline-comment-count" id="/2022/04/function-call/"></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>前言：前几天看了一集南京大学蒋炎岩老师的<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV12L4y1379V/?spm_id_from=333.788">操作系统课程</a>，属于是跪着看完的，真的太强了。先不说讲的非常好，里面的非递归汉诺塔（可以在<a target="_blank" rel="noopener" href="http://jyywiki.cn/OS/2022/slides/2.slides#/2/3">课程网站</a>中找到）就让我对递归和函数调用有了新的理解，并且让我对函数调用的原理有了一些兴趣。所以我决定去详细的了解函数调用的原理，并且写一个类似非递归汉诺塔的东西，比如非递归的 dfs（这部分属于是整活了，非递归的 dfs 并没有显著的性能提升，如果你想把它用在 OI 中那就可以直接跳过这部分了）。</p>
<h1>1：函数调用是如何实现的？</h1>
<h2 id="1-1：一个小例子">1.1：一个小例子</h2>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span>
<span class="token keyword">int</span> <span class="token function">add2</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token punctuation">(</span>a <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>
<span class="token keyword">int</span> <span class="token function">add1</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token punctuation">(</span>a <span class="token operator">+</span> <span class="token function">add2</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">add1</span><span class="token punctuation">(</span><span class="token number">114</span><span class="token punctuation">,</span> <span class="token number">514</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>观察这样一段程序，在主函数中会调用一个 add1 函数，对于 add1，它又会去调用一个 add2，然后返回计算的结果，最后才在主函数中执行 printf。</p>
<p>把这段程序中函数执行完成的顺序： <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>add2</mtext><mo>⇒</mo><mtext>add1</mtext><mo>⇒</mo><mtext>main</mtext></mrow><annotation encoding="application/x-tex">\text{add2} \rArr \text{add1} \rArr \text{main}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord text"><span class="mord">add2</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord text"><span class="mord">add1</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6679em;"></span><span class="mord text"><span class="mord">main</span></span></span></span></span>，和开始执行的顺序：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>main</mtext><mo>⇒</mo><mtext>add1</mtext><mo>⇒</mo><mtext>add2</mtext></mrow><annotation encoding="application/x-tex">\text{main} \rArr \text{add1} \rArr \text{add2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6679em;"></span><span class="mord text"><span class="mord">main</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord text"><span class="mord">add1</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord text"><span class="mord">add2</span></span></span></span></span> 列出来就可以发现。更早开始执行的函数更晚结束，这是因为先开始执行的函数需要用到后开始的函数的结果，所以必须先运行完后开始的函数。</p>
<p>这似乎是一个栈的结构，也就是先进后出的结构，对应到函数调用的场景下，就是先开始执行的就要后结束执行。后开始执行的函数先结束执行。</p>
<p>因为函数调用和栈的相关性，我们可以把每一次函数调用抽象成栈中的一个元素。每次我们都执行栈顶上的函数，如果遇到新调用的函数，就把他推入栈中。而每当一个函数执行完了，就把他弹出栈。</p>
<p>具体可以参考下面这个我用 manim 制作的演示视频：</p>

        <video src='/video/非递归dfs/func_and_stk.mp4' type='video/mp4' controls='controls' width='100%' height='100%'></video>

<h2 id="1-2：栈帧">1.2：栈帧</h2>
<h3 id="1-2-1：基本结构">1.2.1：基本结构</h3>
<p>前面说到可以把函数调用抽象成栈里的一个元素，这个元素就被称之为栈帧 （stake frame），那我们具体要往栈帧里放什么，才能让 cpu 读取了栈帧数据之后就能正确运行函数呢？</p>
<p>首先，在函数中，我们可能会申明一些局部变量，如果我们想要成功的调用一个函数，肯定需要访问函数中的局部变量。</p>
<p>对于传进来的参数，其实也可以看作时一种局部变量。</p>
<p>其次，我们调用的函数执行完之后，需要返回。可是在返回时，计算机并不知道具体应该返回到哪条指令。用前面的例子说，main 函数调用了 add1，可是当 add 返回的时候，不知道接下来应该执行 <code>printf</code> 还是直接在 main 中 <code>return 0</code> 了。所以我们还需要在栈帧中存一个返回的位置，也就是返回之后应该执行哪条指令。</p>
<p>最后呢，就像在用数组模拟栈的时候一样，需要标记栈的栈顶，这样才知道下一个数据往哪里放。对于单个栈帧，除了栈顶（结束地址），还需要知道这个栈帧的 “栈底（起始地址）”，通过这个起始地址，我们才能知道在弹出这个栈帧的时候，要弹到哪里。</p>
<p>在 x86/x64 架构的计算机中，有两个专门的寄存器来标记当前函数栈帧的起始地址和结束地址，分别为 xbp （base pointer 栈基址/帧指针，本文称之为帧指针） 和 xsp （stack pointer 栈指针）。其中的 x 代表这个字母会变化，它代表的计算机的位宽，如果是 64 位的机器，那就是 rbp 和 rsp，而 32 位机器的是 ebp 和 esp。</p>
<p>下面这张图<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="来源为：[https://www.cnblogs.com/zzdbullet/p/9629909.html](https://www.cnblogs.com/zzdbullet/p/9629909.html)
">[1]</span></a></sup>很好的解释了栈帧在栈中的具体结构：<br>
<img src="/img/%E9%9D%9E%E9%80%92%E5%BD%92dfs/%E6%A0%88%E5%B8%A7%E7%BB%93%E6%9E%84.png" alt="栈帧结构"><br>
注：栈的增长方向是高地址到底地址，也就是调用者栈帧的地址比被调用者栈帧的小。</p>
<p>图片的上半部分是调用者的栈帧，可以看到里面存有参数（也就是一种局部变量）。也有当前函数的返回地址，通过这个地址可以找到当前这个函数运行完了应该返回哪里。</p>
<p>返回地址是通过当前栈帧的帧指针确定的，它总是储存在当前帧指针 +8 的位置（在 64 位机器中，如果是图中的 32 位，那就是 +4 的位置）。</p>
<p>下半部分存的是当前函数的栈帧，里面同样存有局部变量。ebp 和 esp 分别标注了这个栈帧的起始和结束位置。</p>
<p>通过帧指针加上一些偏移量，就可以访问到这个栈帧里的局部变量。</p>
<h3 id="1-2-2：调用函数时栈帧的变化">1.2.2：调用函数时栈帧的变化</h3>
<ol>
<li>在调用一个函数时，我们先把函数的返回地址（也就是执行调用时 pc<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="pc 即 program counter, 程序计数器，它指向下一条指令所在的内存单元的地址，通过 pc，计算机总是可以知道下一步该干什么。
">[2]</span></a></sup> 的值）压入栈中。</li>
<li>为了确保返回时能恢复当前帧指针的状态，还需要把帧指针压入栈中。</li>
<li>做完了准备工作，可以加入被调用函数的栈帧了。新栈帧当前还没有存放任何数据，所以起始地址和结束地址都是旧栈帧的结束地址。为了达到这一点，需要把帧指针的值（新栈帧起始值）设置成栈指针（老栈帧结束值）的值。</li>
<li>现在要把数据存入新栈帧，首先会需要更新栈指针的值，扩大栈的范围，因为栈帧是向低地址增长的，所以要根据局部变量及参数的大小，把栈指针的值减小一些。</li>
<li>栈帧已经有了足够的空间，可以放入局部变量并且执行这个函数了。至此，新栈帧的插入完全完成。</li>
</ol>
<h3 id="1-2-3：函数返回时栈帧的变化">1.2.3：函数返回时栈帧的变化</h3>
<ol>
<li>函数返回首先要释放之前占用的所有内存，所以我们直接把栈指针设置成帧指针。也就是把栈帧的结束地址直接改成开始地址，相当于撤销调用函数时的第 4 步。</li>
<li>现在需要用到之前备份的原帧指针来恢复函数调用之前的状态。我们需要从栈中弹出这个原帧指针，然后复制到帧指针寄存器。</li>
<li>弹出返回地址，赋值到 pc。</li>
<li>根据 pc 的值，继续执行原函数。</li>
</ol>
<h3 id="1-2-4：视频解释">1.2.4：视频解释</h3>
<p>看文字解释可能不是很清楚，可以参考下面这个我用 manim 制作的演示视频。演示的是下面这个 C 程序运行时栈帧的变化。</p>
<div class="note info flat"><p>为了演示和理解的方便，假设以下程序中每一行就是 cpu 执行的一条指令，在汇编中实际需要执行更多的步骤（后面会讲）。</p>
</div>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span><span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">114</span><span class="token punctuation">,</span> <span class="token number">514</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> d <span class="token operator">=</span> c <span class="token operator">+</span> <span class="token number">1919</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

        <video src='/video/非递归dfs/detail_func_call.mp4' type='video/mp4' controls='controls' width='100%' height='100%'></video>

<h3 id="1-2-5：Talk-is-cheap-Show-me-the-code">1.2.5：Talk is cheap. Show me the code.</h3>
<p>虽然前面的解释和视频已经能让大部分人了解函数调用的原理了。但要想要深入了解函数调用的详细过程，还是得看编译后的汇编代码。不过不用担心你看不懂汇编代码，我在这部分写了非常详细的解释。</p>
<h4 id="1-2-5-1：如何查看汇编代码">1.2.5.1：如何查看汇编代码</h4>
<p>这里介绍两种查看 C 或 C++ 代码对应的汇编的方法：</p>
<ul>
<li>如果你使用的是 gcc 编译器，可以直接在命令行输入 <code>gcc -S [文件] </code>，不过默认输出的汇编是 at&amp;t 风格的，我个人比较喜欢 intel 风格的汇编，如果你也希望输出 intel 风格的汇编，可以加入编译选项 <code>-m asm=intel</code></li>
<li>直接使用编译器输出汇编可能会包含很多跟系统有关，但是和你的程序无关的代码。而且如果你对汇编不是很熟悉的话，可能不知道 C 里面的一行代码对应的是哪几行汇编代码。这里强烈推荐一个网站，叫做 <a target="_blank" rel="noopener" href="https://gcc.godbolt.org/">Compiler Explorer</a>，可以解决这些问题。</li>
</ul>
<h4 id="1-2-5-2：Compiler-Explorer-的基本介绍">1.2.5.2：Compiler Explorer 的基本介绍</h4>
<p>进入这个网站，基本的界面是这样的：<br>
<img src="/img/%E9%9D%9E%E9%80%92%E5%BD%92dfs/ce%E7%95%8C%E9%9D%A2.png" alt="Compiler Explorer基本界面"><br>
这里只讲几个比较基本的选项，但是这个网站的功能是非常强大的，完全是一个线上的 IDE，具体可以看这个<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1pJ411w7kh?p=93">视频</a><br>
<img src="/img/%E9%9D%9E%E9%80%92%E5%BD%92dfs/ce%E9%80%89%E9%A1%B9.png" alt="Compiler Explorer选项"><br>
可以看到从左到右有一些选项被框起来了，他们的功能分别是：</p>
<ol>
<li>开启 vim 模式，可以用 vim 的方法编辑代码</li>
<li>选择语言，Compiler Explorer 支持 30 多种语言</li>
<li>选择编译器/解释器，顺便提一嘴，这网站能选的 C/C++ 编译器非常多，能支持包括但不限于 Xtensa 这种嵌入式的 cpu，或者 IBM power 架构的 cpu。</li>
<li>输出选项，可以在这里切换 intel/at&amp;t 格式的汇编，也可以选择输出二进制文件</li>
<li>过滤器选项，可以过滤掉和你代码无关的内容</li>
<li>添加编译选项</li>
<li>通过链接分享</li>
</ol>
<p>再回到这张图：<br>
<img src="/img/%E9%9D%9E%E9%80%92%E5%BD%92dfs/ce%E7%95%8C%E9%9D%A2.png" alt="Compiler Explorer基本界面"><br>
可以看到左边的 C++ 和右边的汇编代码都被用不同的颜色标注了起来，被同个颜色标注的代码就表示它们是对应的。</p>
<h4 id="1-2-5-3：分析函数调用的汇编">1.2.5.3：分析函数调用的汇编</h4>
<p>先放代码：</p>
<div class="tabs" id="函数调用汇编代码"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#函数调用汇编代码-1">汇编</button></li><li class="tab"><button type="button" data-href="#函数调用汇编代码-2">c</button></li><li class="tab"><button type="button" data-href="#函数调用汇编代码-3">截图和链接</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="函数调用汇编代码-1"><pre class="line-numbers language-nasm" data-language="nasm"><code class="language-nasm"><span class="token label function">add:</span>
        push    <span class="token register variable">rbp</span>
        mov     <span class="token register variable">rbp</span>, <span class="token register variable">rsp</span>
        mov     DWORD PTR <span class="token operator">[</span><span class="token register variable">rbp</span><span class="token operator">-</span><span class="token number">4</span><span class="token operator">]</span>, <span class="token register variable">edi</span>
        mov     DWORD PTR <span class="token operator">[</span><span class="token register variable">rbp</span><span class="token operator">-</span><span class="token number">8</span><span class="token operator">]</span>, <span class="token register variable">esi</span>
        mov     <span class="token register variable">edx</span>, DWORD PTR <span class="token operator">[</span><span class="token register variable">rbp</span><span class="token operator">-</span><span class="token number">4</span><span class="token operator">]</span>
        mov     <span class="token register variable">eax</span>, DWORD PTR <span class="token operator">[</span><span class="token register variable">rbp</span><span class="token operator">-</span><span class="token number">8</span><span class="token operator">]</span>
        add     <span class="token register variable">eax</span>, <span class="token register variable">edx</span>
        pop     <span class="token register variable">rbp</span>
        ret
<span class="token label function">main:</span>
        push    <span class="token register variable">rbp</span>
        mov     <span class="token register variable">rbp</span>, <span class="token register variable">rsp</span>
        sub     <span class="token register variable">rsp</span>, <span class="token number">16</span>
        mov     <span class="token register variable">esi</span>, <span class="token number">514</span>
        mov     <span class="token register variable">edi</span>, <span class="token number">114</span>
        call    add
        mov     DWORD PTR <span class="token operator">[</span><span class="token register variable">rbp</span><span class="token operator">-</span><span class="token number">4</span><span class="token operator">]</span>, <span class="token register variable">eax</span>
        mov     <span class="token register variable">eax</span>, DWORD PTR <span class="token operator">[</span><span class="token register variable">rbp</span><span class="token operator">-</span><span class="token number">4</span><span class="token operator">]</span>
        add     <span class="token register variable">eax</span>, <span class="token number">1919</span>
        mov     DWORD PTR <span class="token operator">[</span><span class="token register variable">rbp</span><span class="token operator">-</span><span class="token number">8</span><span class="token operator">]</span>, <span class="token register variable">eax</span>
        mov     <span class="token register variable">eax</span>, <span class="token number">0</span>
        leave
        ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="函数调用汇编代码-2"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span><span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">114</span><span class="token punctuation">,</span> <span class="token number">514</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> d <span class="token operator">=</span> c <span class="token operator">+</span> <span class="token number">1919</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="函数调用汇编代码-3"><p><a target="_blank" rel="noopener" href="https://gcc.godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(filename:'1',fontScale:14,fontUsePx:'0',j:1,lang:___c,selection:(endColumn:2,endLineNumber:6,positionColumn:2,positionLineNumber:6,selectionStartColumn:2,selectionStartLineNumber:6,startColumn:2,startLineNumber:6),source:'int+add(int+a,+int+b)%0A++++%7Breturn+a+%2B+b%3B%7D%0Aint+main()%7B%0A++++int+c+%3D+add(114,+514)%3B%0A++++int+d+%3D+c+%2B+1919%3B%0A%7D'),l:'5',n:'0',o:'C+source+%231',t:'0')),k:51.24919923126201,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((h:compiler,i:(compiler:cg102,filters:(b:'0',binary:'1',commentOnly:'0',demangle:'0',directives:'0',execute:'1',intel:'0',libraryCode:'0',trim:'1'),flagsViewOpen:'1',fontScale:14,fontUsePx:'0',j:1,lang:___c,libs:!(),options:'',selection:(endColumn:12,endLineNumber:24,positionColumn:12,positionLineNumber:24,selectionStartColumn:12,selectionStartLineNumber:24,startColumn:12,startLineNumber:24),source:1,tree:'1'),l:'5',n:'0',o:'x86-64+gcc+10.2+(C,+Editor+%231,+Compiler+%231)',t:'0')),k:48.75080076873799,l:'4',m:100,n:'0',o:'',s:0,t:'0')),l:'2',n:'0',o:'',t:'0')),version:4">Compiler Explorer 的分享链接</a><br>
<img src="/img/%E9%9D%9E%E9%80%92%E5%BD%92dfs/ce%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E4%BB%A3%E7%A0%81.png" alt="CE函数调用代码"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>
<p>在 main 函数中，我们直接通过 <code>int c = add(114, 514);</code> 调用了 add 函数，在 C 中，看似一行指令就能成功调用函数，但这一句话实际需要下面的汇编来实现：</p>
<pre class="line-numbers language-nasm" data-language="nasm"><code class="language-nasm">mov     <span class="token register variable">esi</span>, <span class="token number">514</span>              <span class="token comment">; 把 514 赋给 esi 寄存器，用于给 add 函数传递参数</span>
mov     <span class="token register variable">edi</span>, <span class="token number">114</span>              <span class="token comment">; 把 114 赋给 edi 寄存器，用于给 add 函数传递参数</span>
call    add                   <span class="token comment">; 调用 call 函数，详见下面的解释</span>
mov     DWORD PTR <span class="token operator">[</span><span class="token register variable">rbp</span><span class="token operator">-</span><span class="token number">4</span><span class="token operator">]</span>, <span class="token register variable">eax</span><span class="token comment">; 见下面的解释</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>这段代码中的前两个 mov 指令都是比较容易理解的，但是 call 指令一句话却做了两件事情。</p>
<p>首先，call 会把 call 指令执行时的 pc 压入栈中（这个程序中就是 <code>mov     DWORD PTR [rbp-4], eax</code>）。然后，它会把 pc 的值改成 add 函数的起始地址。（pc 存的是 cpu 执行的下一条指令的地址）。然后 cpu 就会开始执行 add 函数。</p>
<p>call 的下一句可能比较难以理解，特别是 <code>DWORD PTR [rbp-4]</code>。其中的 <code>DWORD</code> 表示的其实是一种数据类型，<code>WORD</code> 表示的是两字节的整数，<code>DWORD</code>，也就是 double word，表示的就是四个字节的整数，所以 <code>DWORD</code> 其实就是 C 中的 <code>int</code>。</p>
<p><code>PTR</code> 跟 C 中的解指针操作很像。<code>mov     DWORD PTR [rbp-4], eax</code>。 这一句话就是把 eax 寄存器的值复制到内存中地址为 rbp-4 的位置。并且这个值是四个字节的。所以 eax 的值会被赋值到地址为 rbp-4 到 rbp 的这个范围的内存。</p>
<p>注意 rbp 就是前面说到的帧指针，它保存的是栈帧的开始地址，在函数中，局部变量都是通过帧指针来访问的。而 eax 保存的是 add 的返回值。所以这句话转换成 C 语言就是把 <code>add(114, 514)</code> 的返回值保存到局部变量 <code>c</code>。</p>
<p>现在再来看 add 函数中的内容：</p>
<pre class="line-numbers language-nasm" data-language="nasm"><code class="language-nasm"><span class="token label function">add:</span>
        push    <span class="token register variable">rbp</span>                    <span class="token comment">; 把 rbp 压入栈中，push 指令会先减少 sp 寄存器的值，然后把要入栈的数据存入 sp 指向的位置 （栈顶）</span>
        mov     <span class="token register variable">rbp</span>, <span class="token register variable">rsp</span>               <span class="token comment">; 把 rsp 的值赋到 rbp，这表明新的栈帧内没有存任何数据</span>
        mov     DWORD PTR <span class="token operator">[</span><span class="token register variable">rbp</span><span class="token operator">-</span><span class="token number">4</span><span class="token operator">]</span>, <span class="token register variable">edi</span> <span class="token comment">; edi 和 esi 存着参数</span>
        mov     DWORD PTR <span class="token operator">[</span><span class="token register variable">rbp</span><span class="token operator">-</span><span class="token number">8</span><span class="token operator">]</span>, <span class="token register variable">esi</span> <span class="token comment">; 所以这两行是把参数存入栈中</span>
        mov     <span class="token register variable">edx</span>, DWORD PTR <span class="token operator">[</span><span class="token register variable">rbp</span><span class="token operator">-</span><span class="token number">4</span><span class="token operator">]</span> <span class="token comment">;</span>
        mov     <span class="token register variable">eax</span>, DWORD PTR <span class="token operator">[</span><span class="token register variable">rbp</span><span class="token operator">-</span><span class="token number">8</span><span class="token operator">]</span> <span class="token comment">; 把 a 和 b 这两个参数移动到 edx 和 eax 两个寄存器中</span>
        add     <span class="token register variable">eax</span>, <span class="token register variable">edx</span>               <span class="token comment">; 等价于 eax += edx</span>
        pop     <span class="token register variable">rbp</span>                    <span class="token comment">; 把栈顶的元素送到 rbp，也就是恢复之前备份的 rbp</span>
        ret                            <span class="token comment">; 把之前存的返回地址弹出到 pc，以便继续执行 main 函数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>你可能会感到奇怪，在之前的解释中，sp 指针会先被减去一个值来分配栈帧的空间。在返回时，sp 的值会被设成 bp 的值来释放栈空间。而在上面的代码中，这些操作都没有被执行。</p>
<p>这一系列骚操作其实都是编译器干的，编译器会优化掉一些不必要的操作。对于第一个操作，sp 指针可以告诉我们下次增加栈帧的时候应该往哪加，防止把之前的栈帧覆盖掉，但是这个 add 函数没有调用任何别的函数，也就是不需要再它的基础上增加任何栈帧，所以给 sp 减一个值来分配空间自然就没有必要了。</p>
<p>对于第二个操作，因为 sp 一直没变，自然也无需在返回时更改 sp 的值。</p>
<div class="note info flat"><p>如果你有兴趣，可以去 Compiler Explorer 的网站上加一个 o2 的编译选项，看下我们平时常用的 o2 优化到底是怎么实现的。如果你去看了，发现编译器居然会提前把 114 + 514 + 1919 的值算好，然后就不调用 add 函数了。。。</p>
</div>
<p>假设我们把这个 add 函数改成一个递归的函数，那么刚刚的那些优化就不能加了，要不然就会把之前的栈帧覆盖掉。可以看下<a target="_blank" rel="noopener" href="https://gcc.godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(filename:'1',fontScale:14,fontUsePx:'0',j:1,lang:___c,selection:(endColumn:2,endLineNumber:6,positionColumn:2,positionLineNumber:6,selectionStartColumn:2,selectionStartLineNumber:6,startColumn:2,startLineNumber:6),source:'int+add(int+a,+int+b)%0A++++%7Breturn+add(a,+b)%3B%7D%0Aint+main()%7B%0A++++int+c+%3D+add(114,+514)%3B%0A++++int+d+%3D+c+%2B+1919%3B%0A%7D'),l:'5',n:'0',o:'C+source+%231',t:'0')),k:50.83279948750801,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((h:compiler,i:(compiler:cg85,filters:(b:'0',binary:'1',commentOnly:'0',demangle:'0',directives:'0',execute:'1',intel:'0',libraryCode:'0',trim:'1'),flagsViewOpen:'1',fontScale:14,fontUsePx:'0',j:1,lang:___c,libs:!(),options:'',selection:(endColumn:20,endLineNumber:11,positionColumn:20,positionLineNumber:11,selectionStartColumn:20,selectionStartLineNumber:11,startColumn:20,startLineNumber:11),source:1,tree:'1'),l:'5',n:'0',o:'x86-64+gcc+8.5+(C,+Editor+%231,+Compiler+%231)',t:'0')),k:49.167200512491995,l:'4',m:100,n:'0',o:'',s:0,t:'0')),l:'2',n:'0',o:'',t:'0')),version:4">这个例子</a>。注意其中的 leave 指令会干两件事。第一是把栈指针指向帧指针（帧指针和栈指针相等就表示当前栈帧没有数据），用于恢复之前分配的内存，第二是恢复备份的栈指针。相当于是 <code>mov rsp, rbp</code> 和 <code>pop rsp</code> 的结合。</p>
<h2 id="1-3：不同的函数调用约定-（calling-convention）">1.3：不同的函数调用约定 （calling convention）</h2>
<p>看了刚刚的汇编代码，你可能会好奇，有很多种方法可以实现汇编中的函数调用，为什么编译器采取的就是这样特定的一种。比如为什么函数的参数是由 edi 和 esi 寄存器来进行传递的，不是直接压入栈中或者是用别的寄存器来传，又比如栈帧的释放工作既可以由被调用者完成，也可以由调用者完成，但为什么在刚刚的汇编代码中，是让被调用者来释放栈帧的。</p>
<p>其实，这些看似玄学的问题都是有答案的，答案就是函数调用的约定。</p>
<blockquote>
<p>函数调用约定，是指当一个函数被调用时，函数的参数会被传递给被调用的函数和返回值会被返回给调用函数。函数的调用约定就是描述参数是怎么传递和由谁平衡堆栈的，当然还有返回值。-- 百度百科</p>
</blockquote>
<p>所以这里就来介绍几种比较经典的函数调用约定。如果你自己想要写汇编的话，也可以遵守这些函数调用的规则。</p>
<h3 id="1-3-1：x86（32位机）的函数调用约定">1.3.1：x86（32位机）的函数调用约定</h3>
<p>还是先介绍下查看 x86 汇编代码的方法。gcc 编译器默认输出的汇编是 64 位的，如果想让 gcc 输出 32 位的汇编代码，需要加入 <code>-m32</code> 编译选项，经测试，可以在我的电脑中输出 32 位程序（我的电脑用的是 MinGW），也可以在程序中加入 <code>__cdecl</code> 或是 <code>__stdcall</code> 这样的指令来指定函数调用约定。不过在 Compiler Explorer 中，就有些奇怪了，即使加入了 <code>-m32</code> 的编译选项，还是不能指定函数调用约定，所以我把 Compiler Explorer 的编译器换成了 msvc（用 Compiler Explorer 是因为分享代码很方便）。如果你知道为什么在 gcc 中指定了函数调用约定就过不了编译，欢迎在评论区告诉我。</p>
<p>为了对比不同函数调用约定的具体区别，我使用了同一段代码。然后再在 add 函数的前面加入不同的函数调用约定。这里附上 Compiler Explorer 的<a target="_blank" rel="noopener" href="https://gcc.godbolt.org/#z:OYLghAFBqd5QCxAYwPYBMCmBRdBLAF1QCcAaPECAMzwBtMA7AQwFtMQByARg9KtQYEAysib0QXACx8BBAKoBnTAAUAHpwAMvAFYTStJg1AB9U8lJL6yAngGVG6AMKpaAVxYMQAJlIOAMngMmABy7gBGmMQgAGykAA6oCoS2DM5uHt7xickCAUGhLBFRsZaY1ilCBEzEBGnunlwWmFY2ApXVBHkh4ZF6ClU1dRmN/R1dBUUSAJQWqK7EyOwcgQQA1Kb96KK0tKtM6OgQK3ukq8dhp8fIUwCkGgCCq0%2BrNwDsAELEmATzDHsvXneqzCAKByBuAGZ3m8ACJ3e7HFhMQIQW4feHPM6CVbIF4QmF7A4QLhSU4AVlJqy4AE4abcofDGa8YRwZrROGTeJ4OFpSKhOI5Vgo5gtMACITxSARNKyZgBrECvAB0ZMkkghrwAHNFqZqvF5JJqybF2RxJFyZXzOLwFCANFKZTM4LAkGgWHE6JFyJQ3R76FFkMhaMYggB3YwQnw0WgESK2iBhS1hQLVACenElbrYggA8gxaOmebwsEijOIi6R8F9ygA3TC2iuYVRlVyxjO8FbNS20PBhYhp5xYS0EYh4FjtmZUAzABQANTwmFDObijHbMkEIjE7FJ/EEihU6grukaBiMIFMxnMPbCtsgM1QcVaDAbNuaZSf9gYThc9T0/kC3SFL0jQJEkT5DA0WRgSk4w9FEIxvuUbQDLUP7DE0LQVChsFAfBFgoRBfTYQBEzATMwrzIsegjpgSw8GyHIWhW/IcKo2qrCwCg1riNY0kqUirBAADqACSwTYFMgmOKcuCECQ4qNKszjup6xAKVMvDSkWUzyt4ZJKlqmrUqq0QQhSGiapI1Impw5qkOOXAaPa3K8ixNp2g62mkM6iAoBgOD4EQZAUNQnrMGwa67sI2zbtIUX7molq6D4p4mGYGHvikn7fukniar4X44ZMIHZOBaF5VBOQMEVwEZUhDDtIM5WKnVT6NZ0JFwURHSEa8%2BFjJ1uHTLMlFLMcZhYEGhKHMcTCXNiFxYms1wYs8byfN8vz/DcgLAqCOKQtCzLwoiyIMKi62rU8Vx4gS%2ByHCS0irBST00nSh2Mg8sKsvojGkC5vAsYKFGiuKXiaY6umOUqXgahCmqaq8BoaGZ0QnrZTGudaFgeVpWhOjAvm%2Bqp3oQMT/ooEGIaLhGUZ0LGxDxomFbJswxCFpmqAsNmBB5gWloloYwDlryVaZXWDa8k2LZttwHaCF2FbXv27ODksvIjmOE58NOc4LkuK7cpKUWbuIO6yAlh68sl%2BhC%2Be6XXreqJ8o%2BKQvq1WUQA4hFcPl/75F1JKVWVuUgNSwcwYNxUIZhyE9c1vse3HNQ1fBIwEc14ejCnUfAVw5EilRPg0XRP2mpy/2WixbHRBxXE8XxAnCWJElSTJgXyTtkanMpfqRGDGmefjuleBoMNeK8VmvGSE%2BjxorzWb9ZqY4D2O2vaeM/T5ECuv5slBaT0aMKwpfrtFW4SHFFtKIlR4gBCttnhe5ilPV2WET4/uAZMsSgVVH8R1yLnYoScGoZ1Dj4V%2BbViIByGiUcBv5IEwO/r0aIBdRqcHGsYKgTB%2BjbF2PdI42I5pLWBPNZatwHiYnWl8H4xA/hMH2iCHaYIPrHQeKdFEaJoRUOeDdSEd0iSPXJJSN61J6Q8PuEyFkDEOAVwBlaDgwNC5ii7hCCG2koaSCVAjY0TkrLUleNEMkrwIQP1NHZBRbkcYb0dN5QmO8/IqX9KTcmvRAzBjDLTPg9M4yUGZryVmaY1xZkYLzfMhZRaYFLMLdWxY8DVhsBLS00tkCtlPp2U0vJlYDn8sOUc445aTl1vORcy5VxyzPqbWKZ9LZJXvo/NKl59C9idveV2Ah3ZQM9t7BOftCrAIkCVaCAgP72j/k%2BVOYdQHtR9vlbpycOqwOjv1JqED7TZyWSgqI4iRqigaSXbW5cV6KJrnXbiqxeLUn4pIQSolxKSQgNJVY%2B9O6wwfkpLmfc1JqMHpvHSpAFReC4EqCUaMF60mNNESQZIITSAsSc6x68h6yiXuDSuzFsb/JmHWRmWVJBAA">链接</a></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> c<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span><span class="token keyword">return</span> a <span class="token operator">+</span> b <span class="token operator">+</span> c<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">114</span><span class="token punctuation">,</span> <span class="token number">514</span><span class="token punctuation">,</span> <span class="token number">1919</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<div class="tabs" id="不同调用约定"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#不同调用约定-1">cdecl (C declaration)</button></li><li class="tab"><button type="button" data-href="#不同调用约定-2">stdcall</button></li><li class="tab"><button type="button" data-href="#不同调用约定-3">fastcall</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="不同调用约定-1"><p>如果想要指定函数的调用方法为 cdecl，需要这样申明函数：<code>int __cdecl add(int a, int b, int c)</code>。</p>
<p>cdecl 是 C 语言的默认函数调用方法（32 位时）。它的特点由如下几个：</p>
<ul>
<li>参数通过栈来传递，并且参数由右向左被依次压入栈中。</li>
<li>由调用者负责释放被调用函数占用的内存。或者说手动清栈。</li>
<li>整数返回值存 ax 寄存器上，浮点型返回值存在 st0 寄存器上。</li>
</ul>
<p>前面的代码使用 cdecl 约定生成的汇编如下：</p>
<pre class="line-numbers language-nasm" data-language="nasm"><code class="language-nasm">_a<span class="token operator">$</span> <span class="token operator">=</span> <span class="token number">8</span>                                       <span class="token comment">; size = 4</span>
_b<span class="token operator">$</span> <span class="token operator">=</span> <span class="token number">12</span>                                                <span class="token comment">; size = 4</span>
_c<span class="token operator">$</span> <span class="token operator">=</span> <span class="token number">16</span>                                                <span class="token comment">; size = 4</span>
_add    PROC
        push    <span class="token register variable">ebp</span>
        mov     <span class="token register variable">ebp</span>, <span class="token register variable">esp</span>
        mov     <span class="token register variable">eax</span>, DWORD PTR _a<span class="token operator">$</span><span class="token operator">[</span><span class="token register variable">ebp</span><span class="token operator">]</span>
        add     <span class="token register variable">eax</span>, DWORD PTR _b<span class="token operator">$</span><span class="token operator">[</span><span class="token register variable">ebp</span><span class="token operator">]</span>
        add     <span class="token register variable">eax</span>, DWORD PTR _c<span class="token operator">$</span><span class="token operator">[</span><span class="token register variable">ebp</span><span class="token operator">]</span>
        pop     <span class="token register variable">ebp</span>
        ret     <span class="token number">0</span>
_add    ENDP

_c<span class="token operator">$</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">4</span>                                                <span class="token comment">; size = 4</span>
_main   PROC
        push    <span class="token register variable">ebp</span>
        mov     <span class="token register variable">ebp</span>, <span class="token register variable">esp</span>
        push    <span class="token register variable">ecx</span>
        push    <span class="token number">1919</span>                                    <span class="token comment">; 0000077fH</span>
        push    <span class="token number">514</span>                           <span class="token comment">; 00000202H</span>
        push    <span class="token number">114</span>                           <span class="token comment">; 00000072H</span>
        call    _add
        add     <span class="token register variable">esp</span>, <span class="token number">12</span>                             <span class="token comment">; 0000000cH</span>
        mov     DWORD PTR _c<span class="token operator">$</span><span class="token operator">[</span><span class="token register variable">ebp</span><span class="token operator">]</span>, <span class="token register variable">eax</span>
        xor     <span class="token register variable">eax</span>, <span class="token register variable">eax</span>
        mov     <span class="token register variable">esp</span>, <span class="token register variable">ebp</span>
        pop     <span class="token register variable">ebp</span>
        ret     <span class="token number">0</span>
_main   ENDP<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注意这几句话：</p>
<pre class="line-numbers language-nasm" data-language="nasm"><code class="language-nasm">push    <span class="token number">1919</span>                                    <span class="token comment">; 0000077fH</span>
push    <span class="token number">514</span>                           <span class="token comment">; 00000202H</span>
push    <span class="token number">114</span>                           <span class="token comment">; 00000072H</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>可以看到函数的参数是以从右到左的顺序被压入栈中的。因为使用了 push 指令，在把数据存入栈中的时候就已经减少了 esp 的值，所以你会发现 add 函数中没有减少 esp 指针的值来开辟内存。</p>
<p>和之前分析函数调用原理的那部分一样（见1.2.5.3），这个函数调用没有备份 ebp 也是因为 add 函数没有调用别的函数，所以被编译器优化掉了。</p>
<p>而 <code>add esp, 12</code> 这句话的作用是释放 add 函数占用的内存。并且这句话是出现在 main 函数中的，可以说明 cdecl 的特点，也就是由调用者来释放内存。</p>
<p>那么这样的约定有什么好处呢？</p>
<p>它最主要的好处就是可以采用变长参数（参数的数量不固定）。我们在 C 中最常使用的变长参数函数就是 <code>printf()</code> 和 <code>scanf()</code>。<code>printf</code> 的函数申明是这样的：<code>int printf (const char *__format, ...)</code> 后面的那三个点就代表变长参数。如果你对这样的可变参数有兴趣，推荐去看一看这篇<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/blog/wenge/variable-arguments">洛谷日报</a>。</p>
<p>如果一个程序中有很多地方调用了可变参数函数，每个位置传进去的参数数量可能是不固定的，这就让在可变参数函数内部释放内存变得不现实了。因为在这个函数内部只能释放固定容量的内存，而每次调用需要释放的内存是不同的。如果是让调用者来释放内存的，就可以根据每次调用的参数数量和大小来决定具体要释放空间了。</p>
<p>（当然，你也许可以通过某个寄存器传入需要释的内存大小，或者让被调用函数释放固定的那一部分参数，再让调用者释放可变的那部分参数，不过现在还没有这样的函数调用规则，所以只能在直接编写汇编的时候这样做，而不能在 C/C++ 中指定这样的函数调用约定）。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="不同调用约定-2"><p>如果想要指定函数的调用方法为 stdcall，需要这样申明函数：<code>int __stdcall add(int a, int b, int c)</code>。</p>
<p>stdcall 是绝大多数 Win32 API 使用的函数调用约定。它的特点由如下几个：</p>
<ul>
<li>参数通过栈来传递，并且参数由右向左被依次压入栈中。</li>
<li>被调用函数负责释放被调用函数占用的内存。或者说自动清栈。</li>
<li>其他的特点基本跟 cdecl 相同。</li>
</ul>
<p>前面的代码使用 stdcall 约定生成的汇编如下：</p>
<pre class="line-numbers language-nasm" data-language="nasm"><code class="language-nasm">_a<span class="token operator">$</span> <span class="token operator">=</span> <span class="token number">8</span>                                       <span class="token comment">; size = 4</span>
_b<span class="token operator">$</span> <span class="token operator">=</span> <span class="token number">12</span>                                      <span class="token comment">; size = 4</span>
_c<span class="token operator">$</span> <span class="token operator">=</span> <span class="token number">16</span>                                      <span class="token comment">; size = 4</span>
_add@<span class="token number">12</span> PROC
        push    <span class="token register variable">ebp</span>
        mov     <span class="token register variable">ebp</span>, <span class="token register variable">esp</span>
        mov     <span class="token register variable">eax</span>, DWORD PTR _a<span class="token operator">$</span><span class="token operator">[</span><span class="token register variable">ebp</span><span class="token operator">]</span>
        add     <span class="token register variable">eax</span>, DWORD PTR _b<span class="token operator">$</span><span class="token operator">[</span><span class="token register variable">ebp</span><span class="token operator">]</span>
        add     <span class="token register variable">eax</span>, DWORD PTR _c<span class="token operator">$</span><span class="token operator">[</span><span class="token register variable">ebp</span><span class="token operator">]</span>
        pop     <span class="token register variable">ebp</span>
        ret     <span class="token number">12</span>                            <span class="token comment">; 0000000cH</span>
_add@<span class="token number">12</span> ENDP

_c<span class="token operator">$</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">4</span>                                      <span class="token comment">; size = 4</span>
_main   PROC
        push    <span class="token register variable">ebp</span>
        mov     <span class="token register variable">ebp</span>, <span class="token register variable">esp</span>
        push    <span class="token register variable">ecx</span>
        push    <span class="token number">1919</span>                          <span class="token comment">; 0000077fH</span>
        push    <span class="token number">514</span>                           <span class="token comment">; 00000202H</span>
        push    <span class="token number">114</span>                           <span class="token comment">; 00000072H</span>
        call    _add@<span class="token number">12</span>
        mov     DWORD PTR _c<span class="token operator">$</span><span class="token operator">[</span><span class="token register variable">ebp</span><span class="token operator">]</span>, <span class="token register variable">eax</span>
        xor     <span class="token register variable">eax</span>, <span class="token register variable">eax</span>
        mov     <span class="token register variable">esp</span>, <span class="token register variable">ebp</span>
        pop     <span class="token register variable">ebp</span>
        ret     <span class="token number">0</span>
_main   ENDP<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>从下面这几句话可以看出，stdcall 的压栈顺序和 cdecl 完全一样，也是从左到右的：</p>
<pre class="line-numbers language-nasm" data-language="nasm"><code class="language-nasm">push    <span class="token number">1919</span>                          <span class="token comment">; 0000077fH</span>
push    <span class="token number">514</span>                           <span class="token comment">; 00000202H</span>
push    <span class="token number">114</span>                           <span class="token comment">; 00000072H</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>接下来就是和 cdecl 不同的地方了。注意这一句出现在 add 函数中的话：<code>ret 12 </code>它代表着先 <code>add     esp, 12</code> 再 <code>ret 0</code>。也就是先释放掉 12 字节的内存，然后再返回。这句话说明了在 stdcall 中，函数占用的栈是由函数自己释放掉的。</p>
<p>这样做的主要好处就是可以节省程序的大小。如果参数数量一样的话，清栈就是一件重复的事情，没必要每次调用都多写一句话来清栈，直接在函数内部释放空间就好了。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="不同调用约定-3"><p>如果想要指定函数的调用方法为 stdcall，需要这样申明函数：<code>int __fastcall add(int a, int b, int c)</code>。</p>
<p>fastcall 是一种用于提升函数调用速度的函数调用约定。它会利用寄存器来传递参数。不过，不同于 cdecl 和 stdcall，fastcall 的实现并没有一种明确的标准，不同的编译器可能会编译出不同的东西。以下的特点来自于<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/cpp/cpp/fastcall?view=msvc-170">Visual Studio 2022 的标准</a>。</p>
<ul>
<li>在参数列表中从左到右找出前两个 32 位整数或更小的参数用 ecx 和 edx 寄存器传递。其他的参数以从右到左的顺序通过栈传递。</li>
<li>由被调用函数释放内存（同 stdcall）</li>
</ul>
<p>前面的代码使用 fastcall 约定生成的汇编如下：</p>
<pre class="line-numbers language-nasm" data-language="nasm"><code class="language-nasm">_b<span class="token operator">$</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">8</span>                                                <span class="token comment">; size = 4</span>
_a<span class="token operator">$</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">4</span>                                                <span class="token comment">; size = 4</span>
_c<span class="token operator">$</span> <span class="token operator">=</span> <span class="token number">8</span>                                       <span class="token comment">; size = 4</span>
@add@<span class="token number">12</span> PROC
        push    <span class="token register variable">ebp</span>
        mov     <span class="token register variable">ebp</span>, <span class="token register variable">esp</span>
        sub     <span class="token register variable">esp</span>, <span class="token number">8</span>
        mov     DWORD PTR _b<span class="token operator">$</span><span class="token operator">[</span><span class="token register variable">ebp</span><span class="token operator">]</span>, <span class="token register variable">edx</span>
        mov     DWORD PTR _a<span class="token operator">$</span><span class="token operator">[</span><span class="token register variable">ebp</span><span class="token operator">]</span>, <span class="token register variable">ecx</span>
        mov     <span class="token register variable">eax</span>, DWORD PTR _a<span class="token operator">$</span><span class="token operator">[</span><span class="token register variable">ebp</span><span class="token operator">]</span>
        add     <span class="token register variable">eax</span>, DWORD PTR _b<span class="token operator">$</span><span class="token operator">[</span><span class="token register variable">ebp</span><span class="token operator">]</span>
        add     <span class="token register variable">eax</span>, DWORD PTR _c<span class="token operator">$</span><span class="token operator">[</span><span class="token register variable">ebp</span><span class="token operator">]</span>
        mov     <span class="token register variable">esp</span>, <span class="token register variable">ebp</span>
        pop     <span class="token register variable">ebp</span>
        ret     <span class="token number">4</span>
@add@<span class="token number">12</span> ENDP

_c<span class="token operator">$</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">4</span>                                                <span class="token comment">; size = 4</span>
_main   PROC
        push    <span class="token register variable">ebp</span>
        mov     <span class="token register variable">ebp</span>, <span class="token register variable">esp</span>
        push    <span class="token register variable">ecx</span>
        push    <span class="token number">1919</span>                                    <span class="token comment">; 0000077fH</span>
        mov     <span class="token register variable">edx</span>, <span class="token number">514</span>                      <span class="token comment">; 00000202H</span>
        mov     <span class="token register variable">ecx</span>, <span class="token number">114</span>                      <span class="token comment">; 00000072H</span>
        call    @add@<span class="token number">12</span>
        mov     DWORD PTR _c<span class="token operator">$</span><span class="token operator">[</span><span class="token register variable">ebp</span><span class="token operator">]</span>, <span class="token register variable">eax</span>
        xor     <span class="token register variable">eax</span>, <span class="token register variable">eax</span>
        mov     <span class="token register variable">esp</span>, <span class="token register variable">ebp</span>
        pop     <span class="token register variable">ebp</span>
        ret     <span class="token number">0</span>
_main   ENDP<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>观察这几句话：</p>
<pre class="line-numbers language-nasm" data-language="nasm"><code class="language-nasm">push    <span class="token number">1919</span>                                    <span class="token comment">; 0000077fH</span>
mov     <span class="token register variable">edx</span>, <span class="token number">514</span>                      <span class="token comment">; 00000202H</span>
mov     <span class="token register variable">ecx</span>, <span class="token number">114</span>                      <span class="token comment">; 00000072H</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>可以看到前两个参数，也就是 114 和 154 都是被寄存器传递的，而最后一个参数，也就是 1919，被推入了栈中。这符合前面提到的第一个特点。</p>
<p>而在 add 函数中的 <code>ret 4</code> 又说明了被调用函数释放了内存。因为只有一个参数是在栈中的，其他两个都在寄存器中，所以这个函数只占用了 4 字节的空间，释放掉的空间也自然是 4 字节。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>
<h3 id="1-3-2：x64（64位机）的函数调用约定">1.3.2：x64（64位机）的函数调用约定</h3>
<p>在 x86 的机器中，一共只有 8 个通用寄存器，这就造成了大部分的函数调用都只能使用栈来传递参数，不过这样的速度是比较慢的。在 x64 平台中，一共有 16 个通用寄存器，比 x86 多了 8 个，充足的硬件资源也让我们有机会使用寄存器来传递参数。所以在 x64 平台上，几乎所有的函数调用约定都和 x86 上的 fastcall 相似，也就是尽量使用寄存器传参。</p>
<p>x64 平台下的函数调用约定主要有微软的调用约定和 System V AMD64 ABI 两种。这里我主要介绍 System V AMD64 ABI 约定。此约定主要在Solaris，GNU/Linux，FreeBSD和其他非微软OS上使用。如果你想了解微软的约定，可以参考这个<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/cpp/build/x64-calling-convention?view=msvc-170">网页</a>。</p>
<p>这个调用约定的代码我就不放了，因为之前解释栈帧和函数调用原理时的汇编代码遵守的就是这个约定。</p>
<p>这个约定又如下的主要特点：</p>
<ul>
<li>前 6 个整数和指针参数使用 RDI，RSI，RDX，RCX，R8，R9 寄存器以从左到右的顺序传递。</li>
<li>前 8 个 float 通过 xmm0-xmm7 寄存器以从左到右的顺序传递。</li>
<li>其他参数会被从右到左的压入栈中。</li>
<li>被调用函数负责清栈</li>
</ul>
<p>不过了解了这些函数调用规则又有什么用呢？除了更深入的了解函数调用的实现方法，还可以跨语言的调用函数。函数调用约定详细的规定了调用者和被调用者的职责，也规定了参数的传递方法。这样，只要调用者和被调用者都遵守约定，就可以在一个语言中调用另一个语言写成的函数了。比如在 Python 中使用 Ctypes 库调用 C 函数时，就需要指定函数的调用约定来加载动态链接库（dll 文件）。</p>
<p>此外，还有一些别的函数调用约定，如果你有兴趣，可以参考这几个网页：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/cpp/cpp/calling-conventions?view=msvc-170">https://docs.microsoft.com/zh-cn/cpp/cpp/calling-conventions?view=msvc-170</a></li>
<li><a target="_blank" rel="noopener" href="https://www.laruence.com/2008/04/01/116.html">https://www.laruence.com/2008/04/01/116.html</a></li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/X86%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A">https://zh.wikipedia.org/wiki/X86%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A</a></li>
</ol>
<h1>2：如何写一个不用递归的 dfs 来遍历树</h1>
<h2 id="2-1：具体实现">2.1：具体实现</h2>
<p>通过刚刚的分析，我们已经非常清楚函数调用的实现原理了。如果要实现一个不递归的 dfs，最简单的方法就是自己模拟汇编中函数调用的过程。</p>
<p>先来看一下一个使用递归的 dfs 是怎么写的，相信大家都很熟悉：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;bits/stdc++.h></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> MAXN <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span>
vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> e<span class="token punctuation">[</span>MAXN<span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> cur<span class="token punctuation">,</span> <span class="token keyword">int</span> fa<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"vised %d\n"</span><span class="token punctuation">,</span> cur<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> nex<span class="token operator">:</span>e<span class="token punctuation">[</span>cur<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>nex <span class="token operator">!=</span> fa<span class="token punctuation">)</span> <span class="token function">dfs</span><span class="token punctuation">(</span>nex<span class="token punctuation">,</span> cur<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> n<span class="token punctuation">;</span>
	<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#123;</span>
		<span class="token keyword">int</span> from<span class="token punctuation">,</span> to<span class="token punctuation">;</span>
		<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>from<span class="token punctuation">,</span> <span class="token operator">&amp;</span>to<span class="token punctuation">)</span><span class="token punctuation">;</span>
		e<span class="token punctuation">[</span>from<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>to<span class="token punctuation">)</span><span class="token punctuation">;</span>
		e<span class="token punctuation">[</span>to<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>from<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token function">dfs</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">system</span><span class="token punctuation">(</span><span class="token string">"pause"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看到，dfs 函数中的局部变量或参数有两个： <code>cur</code> 和 <code>fa</code> 分别表示当前节点和父节点</p>
<p>回想一下一个栈帧的结构，里面包含着局部变量，备份的 bp 以及返回地址（调用时的 pc）。其中，备份的 bp 是为了让 bp 回到调用者的状态而准备的。调用者者需要通过 bp 来正确的访问局部变量。不过，我们可以把单个栈帧封装成一个结构体，然后把整个栈当作类型为栈帧类的数组，再用数组来模拟栈。这样，不需要存 bp 也能正确的访问每个栈帧里的局部变量了。</p>
<p>可以这样写这个结构体来代表栈帧，里面只包含 pc 作为返回地址（或者说当前这个函数执行到了哪里）和局部变量（参数）。对于 dfs，必须要备份 pc 的值，因为当前这个函数还没执行完就要去执行下一个函数了，等到被调用的函数执行好时，我们需要备份的 pc 来继续执行当前的函数 （而不是从头开始执行当前函数）：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">PARA_TYPE</span><span class="token operator">></span> <span class="token comment">// PARA_TYPE 是参数的类型</span>
<span class="token keyword">struct</span> <span class="token class-name">Frame</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> pc<span class="token punctuation">;</span><span class="token comment">//如名</span>
    PARA_TYPE paras<span class="token punctuation">;</span><span class="token comment">//当前栈帧的参数</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>然后通过这个结构体来模拟栈的操作：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">FRAME_TYPE</span><span class="token operator">></span><span class="token comment">//栈帧的类型</span>
<span class="token keyword">struct</span> <span class="token class-name">Mystk</span><span class="token punctuation">&#123;</span>
    FRAME_TYPE stk<span class="token punctuation">[</span>E_SZ<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> sp<span class="token punctuation">;</span><span class="token comment">//指向栈顶</span>
    <span class="token function">Mystk</span><span class="token punctuation">(</span><span class="token punctuation">)</span>     <span class="token punctuation">&#123;</span>sp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token function">memset</span><span class="token punctuation">(</span>stk<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>stk<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//构造函数，用于初始化这个栈</span>
    <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span>FRAME_TYPE x<span class="token punctuation">)</span>   <span class="token punctuation">&#123;</span> stk<span class="token punctuation">[</span><span class="token operator">++</span>sp<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//这些操作估计都很熟悉了，不解释</span>
    <span class="token keyword">inline</span> FRAME_TYPE<span class="token operator">&amp;</span> <span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span>         <span class="token punctuation">&#123;</span><span class="token keyword">return</span> stk<span class="token punctuation">[</span>sp<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>
    <span class="token keyword">inline</span> <span class="token keyword">bool</span> <span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span>              <span class="token punctuation">&#123;</span><span class="token keyword">return</span> sp <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>
    <span class="token keyword">inline</span> <span class="token keyword">bool</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token operator">--</span>sp<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>最后，还有这个结构体，相当于把前面的两个结合了一下</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">PARA_TYPE</span><span class="token operator">></span>
<span class="token keyword">struct</span> <span class="token class-name">Func_stk</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">struct</span> <span class="token class-name">Frame</span><span class="token punctuation">&#123;</span>
        <span class="token keyword">int</span> pc<span class="token punctuation">;</span>
        PARA_TYPE paras<span class="token punctuation">;</span>
        <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">my_goto</span><span class="token punctuation">(</span><span class="token keyword">int</span> line<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>pc <span class="token operator">=</span> line <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>
        <span class="token comment">//自定义的 goto 语句，pc 指向将要执行的指令，直接修改 pc 相当于直接修改下个执行的指令</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    Mystk<span class="token operator">&lt;</span>Frame<span class="token operator">></span> cur_stk<span class="token punctuation">;</span>
    <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">call</span><span class="token punctuation">(</span>PARA_TYPE paras<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>cur_stk<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token punctuation">.</span>pc <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">.</span>paras <span class="token operator">=</span> paras<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>
    <span class="token comment">//新调用一次函数就相当于新把一个栈帧推入栈中，并且刚刚调用的时候，这个函数应该执行第一行。</span>
    <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">ret</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                 <span class="token punctuation">&#123;</span>cur_stk<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>
    <span class="token comment">//返回一个函数就相当于在栈中弹出一个栈帧</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>有了这些结构体，要如何在 dfs 函数中使用呢？只要模拟汇编中函数调用的过程，就一定不会出问题，我们可以根据下面这些条件来写出非递归的 dfs。</p>
<ol>
<li>如果要调用函数，直接把新的栈帧推入栈中，也就是使用 <code>Func_stk</code> 的 <code>call</code> 函数</li>
<li>如果要返回当前的函数，就弹出一个栈帧，也就是使用 <code>Func_stk</code> 的 <code>ret</code> 函数</li>
<li>其他的情况下，按照当前的 pc 值执行不同的语句</li>
<li>每执行完一条语句 pc 就要 +1</li>
</ol>
<p>根据 pc 执行不同的语句可以这样实现</p>
<p>然后就可以写出下面的代码:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> cur<span class="token punctuation">,</span> <span class="token keyword">int</span> fa<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    Func_stk<span class="token operator">&lt;</span>Dfs_paras<span class="token operator">></span> dfs_stk<span class="token punctuation">;</span>
    dfs_stk<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>cur<span class="token punctuation">,</span> fa<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//压入第一个栈帧</span>
    Func_stk<span class="token operator">&lt;</span>Dfs_paras<span class="token operator">></span><span class="token double-colon punctuation">::</span>Frame <span class="token operator">*</span>cur_frame <span class="token operator">=</span> <span class="token operator">&amp;</span>dfs_stk<span class="token punctuation">.</span>cur_stk<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//指向当前栈帧的指针</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> <span class="token operator">!</span>dfs_stk<span class="token punctuation">.</span>cur_stk<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> cur_frame<span class="token operator">-></span>pc<span class="token operator">++</span><span class="token punctuation">,</span> cur_frame <span class="token operator">=</span> <span class="token operator">&amp;</span>dfs_stk<span class="token punctuation">.</span>cur_stk<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> 
    <span class="token comment">//只要栈帧不为空就一直循环下去，每执行完一条指令把当前栈帧的 pc++，</span>
    <span class="token comment">//也就是如果某个时候有一个函数想返回当前这个函数，那每当前这个函数每执行完一条指令，返回的位置都要增加 1</span>
    <span class="token comment">//cur_frame = &amp;dfs_stk.cur_stk.top() 用来确保指向当前栈帧的指针一定指向栈顶的栈帧</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>cur_frame<span class="token operator">-></span>pc <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token comment">//dfs函数的第一条指令是打印当前访问的节点，会在 pc=0 的时候被执行                         </span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"vised %d\n"</span><span class="token punctuation">,</span> cur_frame<span class="token operator">-></span>paras<span class="token punctuation">.</span>cur<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cur_frame<span class="token operator">-></span>pc <span class="token operator">&lt;=</span> e<span class="token punctuation">[</span>cur_frame<span class="token operator">-></span>paras<span class="token punctuation">.</span>cur<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                 <span class="token comment">//如果 pc 小于等于跟这个节点相连的边的数量</span>
                                                                                   <span class="token comment">//那肯定还没有完全访问完跟这个节点相连的子树，</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">[</span>cur_frame<span class="token operator">-></span>paras<span class="token punctuation">.</span>cur<span class="token punctuation">]</span><span class="token punctuation">[</span>cur_frame<span class="token operator">-></span>pc <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> cur_frame<span class="token operator">-></span>paras<span class="token punctuation">.</span>fa<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//所以如果下一个节点不是自己的父节点，就继续 “递归”</span>
                dfs_stk<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token punctuation">.</span>cur <span class="token operator">=</span> e<span class="token punctuation">[</span>cur_frame<span class="token operator">-></span>paras<span class="token punctuation">.</span>cur<span class="token punctuation">]</span><span class="token punctuation">[</span>cur_frame<span class="token operator">-></span>pc <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">.</span>fa <span class="token operator">=</span> cur_frame<span class="token operator">-></span>paras<span class="token punctuation">.</span>cur<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">else</span><span class="token punctuation">&#123;</span>
            dfs_stk<span class="token punctuation">.</span><span class="token function">ret</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//如果 pc 的值大于 e[cur_frame->paras.cur].size() 了，就说明和这个节点相连的子树已经全部访问完了，所以需要返回</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>下面是完整代码，欢迎大家赋值下来去自己的电脑上试一试：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;bits/stdc++.h></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> E_SZ <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span> <span class="token comment">// 最大边数</span>

<span class="token keyword">struct</span> <span class="token class-name">Dfs_paras</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> cur<span class="token punctuation">,</span> fa<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> e<span class="token punctuation">[</span>E_SZ<span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">FRAME_TYPE</span><span class="token operator">></span>
<span class="token keyword">struct</span> <span class="token class-name">Mystk</span><span class="token punctuation">&#123;</span>
    FRAME_TYPE stk<span class="token punctuation">[</span>E_SZ<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> sp<span class="token punctuation">;</span><span class="token comment">//指向栈顶</span>
    <span class="token function">Mystk</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>sp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token function">memset</span><span class="token punctuation">(</span>stk<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>stk<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//构造函数，用于初始化这个栈</span>
    <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span>FRAME_TYPE x<span class="token punctuation">)</span>   <span class="token punctuation">&#123;</span> stk<span class="token punctuation">[</span><span class="token operator">++</span>sp<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//这些操作估计都很熟悉了，不解释</span>
    <span class="token keyword">inline</span> FRAME_TYPE<span class="token operator">&amp;</span> <span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span>         <span class="token punctuation">&#123;</span><span class="token keyword">return</span> stk<span class="token punctuation">[</span>sp<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>
    <span class="token keyword">inline</span> <span class="token keyword">bool</span> <span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span>             <span class="token punctuation">&#123;</span><span class="token keyword">return</span> sp <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>
    <span class="token keyword">inline</span> <span class="token keyword">bool</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>           <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token operator">--</span>sp<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">PARA_TYPE</span><span class="token operator">></span>
<span class="token keyword">struct</span> <span class="token class-name">Func_stk</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">struct</span> <span class="token class-name">Frame</span><span class="token punctuation">&#123;</span>
        <span class="token keyword">int</span> pc<span class="token punctuation">;</span>
        PARA_TYPE paras<span class="token punctuation">;</span>
        <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">my_goto</span><span class="token punctuation">(</span><span class="token keyword">int</span> line<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>pc <span class="token operator">=</span> line <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    Mystk<span class="token operator">&lt;</span>Frame<span class="token operator">></span> cur_stk<span class="token punctuation">;</span>
    <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">call</span><span class="token punctuation">(</span>PARA_TYPE paras<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>cur_stk<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token punctuation">.</span>pc <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">.</span>paras <span class="token operator">=</span> paras<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>
    <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">ret</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                 <span class="token punctuation">&#123;</span>cur_stk<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> cur<span class="token punctuation">,</span> <span class="token keyword">int</span> fa<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    Func_stk<span class="token operator">&lt;</span>Dfs_paras<span class="token operator">></span> dfs_stk<span class="token punctuation">;</span>
    dfs_stk<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>cur<span class="token punctuation">,</span> fa<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Func_stk<span class="token operator">&lt;</span>Dfs_paras<span class="token operator">></span><span class="token double-colon punctuation">::</span>Frame <span class="token operator">*</span>cur_frame <span class="token operator">=</span> <span class="token operator">&amp;</span>dfs_stk<span class="token punctuation">.</span>cur_stk<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> <span class="token operator">!</span>dfs_stk<span class="token punctuation">.</span>cur_stk<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> cur_frame<span class="token operator">-></span>pc<span class="token operator">++</span><span class="token punctuation">,</span> cur_frame <span class="token operator">=</span> <span class="token operator">&amp;</span>dfs_stk<span class="token punctuation">.</span>cur_stk<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//执行当前dfs函数，每次pc都要++</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>cur_frame<span class="token operator">-></span>pc <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"vised %d\n"</span><span class="token punctuation">,</span> cur_frame<span class="token operator">-></span>paras<span class="token punctuation">.</span>cur<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cur_frame<span class="token operator">-></span>pc <span class="token operator">&lt;=</span> e<span class="token punctuation">[</span>cur_frame<span class="token operator">-></span>paras<span class="token punctuation">.</span>cur<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">[</span>cur_frame<span class="token operator">-></span>paras<span class="token punctuation">.</span>cur<span class="token punctuation">]</span><span class="token punctuation">[</span>cur_frame<span class="token operator">-></span>pc <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> cur_frame<span class="token operator">-></span>paras<span class="token punctuation">.</span>fa<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
                dfs_stk<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token punctuation">.</span>cur <span class="token operator">=</span> e<span class="token punctuation">[</span>cur_frame<span class="token operator">-></span>paras<span class="token punctuation">.</span>cur<span class="token punctuation">]</span><span class="token punctuation">[</span>cur_frame<span class="token operator">-></span>pc <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">.</span>fa <span class="token operator">=</span> cur_frame<span class="token operator">-></span>paras<span class="token punctuation">.</span>cur<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">else</span><span class="token punctuation">&#123;</span>
            dfs_stk<span class="token punctuation">.</span><span class="token function">ret</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> n<span class="token punctuation">;</span>
    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token keyword">int</span> from<span class="token punctuation">,</span> to<span class="token punctuation">;</span>
        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>from<span class="token punctuation">,</span> <span class="token operator">&amp;</span>to<span class="token punctuation">)</span><span class="token punctuation">;</span>
        e<span class="token punctuation">[</span>from<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>to<span class="token punctuation">)</span><span class="token punctuation">;</span>
        e<span class="token punctuation">[</span>to<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>from<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">system</span><span class="token punctuation">(</span><span class="token string">"pause"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="2-2：小优化">2.2：小优化</h2>
<p>观察原来的 dfs 函数</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> cur<span class="token punctuation">,</span> <span class="token keyword">int</span> fa<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"vised %d\n"</span><span class="token punctuation">,</span> cur<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> nex<span class="token operator">:</span>e<span class="token punctuation">[</span>cur<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>nex <span class="token operator">!=</span> fa<span class="token punctuation">)</span> <span class="token function">dfs</span><span class="token punctuation">(</span>nex<span class="token punctuation">,</span> cur<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>不难发现新调用的函数和当前函数有一个相同的参数，那就是 <code>cur</code>。也就是说，下一个被调用的函数的 <code>fa</code> 参数就是当前函数的 <code>cur</code> 参数。所以我们完全可以在判断 <code>nex != fa</code> 的时候不适用 <code>fa</code>，而是直接去访问上一个栈帧中的 <code>cur</code> 参数，具体写法的话，可以把 <code>fa</code> 改成这样：<code>dfs_stk.stk[dfs_stk.sp-1].paras</code>（paras 是一个 <code>int</code>，因为不需要再在参数中包含 <code>fa</code> 了）。</p>
<p>这样就可以省下一部分空间了。</p>
<h2 id="2-3：所以，有什么用？？">2.3：所以，有什么用？？</h2>
<p><s>纯教学意义，加深对于函数调用实现原理的理解，没有实际用途</s>其实还是有点用的</p>
<h3 id="2-3-1：测试方法">2.3.1：测试方法</h3>
<p>为了更准确的对比非递归 dfs 和正常的写法，我使用 python 加洛谷的 CYaRon 测试数据生成器（强烈推荐，真的方便）生成了 10 个测试点。每个测试点都是一个节点数量为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mi>e</mi><mn>6</mn></mrow><annotation encoding="application/x-tex">1e6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span><span class="mord mathnormal">e</span><span class="mord">6</span></span></span></span> 的树。</p>
<p>输入数据生成器的代码：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> cyaron <span class="token keyword">import</span> <span class="token operator">*</span>
<span class="token keyword">def</span> <span class="token function">generate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    MX_PT <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span><span class="token number">1e6</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        test_data <span class="token operator">=</span> IO<span class="token punctuation">(</span>file_prefix<span class="token operator">=</span><span class="token string">"tree"</span><span class="token punctuation">,</span> data_id<span class="token operator">=</span>_<span class="token punctuation">)</span>
        cur_tree <span class="token operator">=</span> Graph<span class="token punctuation">.</span>tree<span class="token punctuation">(</span>MX_PT<span class="token punctuation">)</span>
        test_data<span class="token punctuation">.</span>input_writeln<span class="token punctuation">(</span>MX_PT <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
        test_data<span class="token punctuation">.</span>input_writeln<span class="token punctuation">(</span>cur_tree<span class="token punctuation">)</span>
<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>
    generate<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>答案生成器：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;bits/stdc++.h></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> MAXN <span class="token operator">=</span> <span class="token number">1e6</span> <span class="token operator">+</span> <span class="token number">5</span><span class="token punctuation">;</span>
vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> e<span class="token punctuation">[</span>MAXN<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> cur<span class="token punctuation">,</span> <span class="token keyword">int</span> fa<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> cur<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> nex<span class="token operator">:</span>e<span class="token punctuation">[</span>cur<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>nex <span class="token operator">!=</span> fa<span class="token punctuation">)</span> <span class="token function">dfs</span><span class="token punctuation">(</span>nex<span class="token punctuation">,</span> cur<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> fid <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> fid <span class="token operator">&lt;=</span> <span class="token number">10</span><span class="token punctuation">;</span> fid<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        string cur_name <span class="token operator">=</span> <span class="token string">"tree"</span> <span class="token operator">+</span> <span class="token function">to_string</span><span class="token punctuation">(</span>fid<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> _ <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> _ <span class="token operator">&lt;</span> MAXN<span class="token punctuation">;</span> _<span class="token operator">++</span><span class="token punctuation">)</span> e<span class="token punctuation">[</span>_<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">freopen</span><span class="token punctuation">(</span><span class="token punctuation">(</span>cur_name <span class="token operator">+</span> <span class="token string">".in"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">,</span> <span class="token constant">stdin</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">freopen</span><span class="token punctuation">(</span><span class="token punctuation">(</span>cur_name <span class="token operator">+</span> <span class="token string">".out"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"w"</span><span class="token punctuation">,</span> <span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> n<span class="token punctuation">;</span>
        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            <span class="token keyword">int</span> from<span class="token punctuation">,</span> to<span class="token punctuation">,</span> none<span class="token punctuation">;</span>
            <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>from<span class="token punctuation">,</span> <span class="token operator">&amp;</span>to<span class="token punctuation">,</span> <span class="token operator">&amp;</span>none<span class="token punctuation">)</span><span class="token punctuation">;</span>
            e<span class="token punctuation">[</span>from<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>to<span class="token punctuation">)</span><span class="token punctuation">;</span>
            e<span class="token punctuation">[</span>to<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>from<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>随后在洛谷上开了个<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/U214511">题目</a>，然后把数据传上去了。之后所有的测试均使用这个题目。</p>
<h3 id="2-3-2：空间？">2.3.2：空间？</h3>
<p>理论上来说，经过刚才的优化，非递归 dfs 的空间占用应该会比正常写法小大约 4MB （每个栈帧中都少了一个 <code>int</code>，最多能有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mi>e</mi><mn>6</mn></mrow><annotation encoding="application/x-tex">1e6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span><span class="mord mathnormal">e</span><span class="mord">6</span></span></span></span> 个栈帧），以及 bp 的大小（见前文，使用结构体封装栈帧，不需要记录 bp）。</p>
<p>想到这里，我赶紧去把常规写法的 dfs 交了一下，以便等下可以对比数据来体现我这个写法的高明。</p>
<p>结果如下：</p>
<table>
<thead>
<tr>
<th>时间（s）</th>
<th>空间（MB）</th>
</tr>
</thead>
<tbody>
<tr>
<td>9.06</td>
<td>55</td>
</tr>
</tbody>
</table>
<p>详见<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/record/list?pid=U214511">提交记录</a></p>
<p>那实际上呢？</p>
<p>一顿操作猛如虎，一看空间 62（MB）。一顿操作猛如虎，一看时间 9.2（s）</p>
<p>不仅空间不降反增，时间也更长了。</p>
<p>详见<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/record/74546760">提交记录</a></p>
<p>为啥呢？</p>
<p>经过我一段时间的思考，感觉多出来的空间占用是栈的问题。虽然单个栈帧占用的空间更少了，但我是使用数组模拟栈的，弹出的栈帧不能被释放掉，而是还留在内存中。而且很多开出来的内存是空的，并没有被使用。在常规的 dfs 中，弹出一个栈帧后，内存立刻就被释放掉了。可是如何证明这个呢？也许我可以不使用数组模拟栈，而是使用一个真正的栈，只要一个栈帧被弹出，就把它占用的内存释放掉。</p>
<p>要达到这一点，可以选择 stl 的 <code>stack</code>。事实证明，使用 stl 后，空间占用和常规的写法完全一样，可是时间就比较一言难尽了，毕竟是 stl，达到了 10.26 秒。<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/record/74546780">提交记录</a></p>
<p>至于为什么没有比常规的写法占用更少的内存，我就不是很清楚了，如果你知道，欢迎在评论区告诉我。</p>
<h3 id="2-3-3：时间？">2.3.3：时间？</h3>
<p>现在我们已经了解了空间占用的问题，可为什么时间会更慢呢？理论上来说，这样模拟的函数调用，应该会比正常写法的 dfs 快一点。因为我弹出或者推入一个栈帧只需要把栈顶指针 <code>++</code> 或者 <code>--</code>。而常规的 dfs 则需要一堆繁琐的步骤（见 1.2.2 和 1.2.3）。</p>
<p>我想了挺久还是没想出来，还是看下<a target="_blank" rel="noopener" href="https://gcc.godbolt.org/#z:OYLghAFBqd5QCxAYwPYBMCmBRdBLAF1QCcAaPECAMzwBtMA7AQwFtMQByARg9KtQYEAysib0QXACx8BBAKoBnTAAUAHpwAMvAFYTStJg1DIApACYAQuYukl9ZATwDKjdAGFUtAK4sGEgGykrgAyeAyYAHI%2BAEaYxCBmZqQADqgKhE4MHt6%2BASlpGQKh4VEssfGJtpj2jgJCBEzEBNk%2BflyBdpgOmfWNBMWRMXEJSQoNTS257bbj/WGDZcOJAJS2qF7EyOwc5gDMYcjeWADUJrtu0YQKAPRj6KaW1gB0CGfYJhoAgl7pRsfMbAUySYW2OdzOVi%2BaAYY2OYQIx2wAH0hAAtU67AAixy4mH8p0sxwArBDjtdrqdsP4TABONwmAAcGhM2BJn0kJk%2BAHYWQyTBZ3hYaSzqTSSRZmV8Pp8AG5dIjEM5ueFvY6YExEgUo1EazEQ6XSgiYFjJAxGjFuAgAT2SjFYmGOADEAEqfACyyIAKgBNZTvXbvL5jYheBzHN1WsYAaxMXMhn2Oiadro9SJ9frBBBjmuRaN1%2Bq%2BSbhgjByQh5JFjPpDJ5rNpzJpXErn2ZDL52GFnybFmphaTEejEGWRdOcaBGOxzN2FmObBYSgIEGjpGOGhX6QAXphUFQl1nlst9VzMRWqbT3gyOR3GcyWyySTX%2BXqz2L%2BczsI7%2BdX6dgeTSOZ87YchYnyMu8dZtrSz5sjyDJWBB9I0tS2B8hYn40sK2DAXynygWed6QX2iZhLQ8zHDKqB4OgxzJD8CAQC67per62DHKow6JrGM7RhqViPJYQK6hObFHie1y8vy6GYcBoE0vBoq7Iyz7AXqdIssB9IShJnzvF2LLCgyikWNB/IXu2sGip%2BZ4MmYjLSfyoEMshn4WN%2B6n8nyDLPjhPKfIp16PgyoFEcWpHhMmTFpix5j4kQyRDiORZccQmAEBsDCZtmFiCUSerTrGeohSRZHRKgnhqia1oJYlNXJal6WlhaZyTqJ0pFsV4UUVRNGoPFHE1bVY7JAAtMNrVSseBbBZ8RommaDpKtatoAg6yifK6UV%2Bm80rBqGCKOl4DDIEiPETfGRa7WGjrEPaXFtTV8I0aY%2BUhUWa0bemrHAjdChTQNHUOl11EsFaSLAKgRAQI9YWYIecbJMgwkw8cw04uNCZJgVf39pGWZKtdt0BscyAbCdeMvRjxEMMjQPE2ItAQO9nybV9jRMAow5cSTxBk1GTy0Qo9FcfziPNauK782zCjCd97MFYe%2BWTUV1NkbTKWLv1A2JVzpPRvzvVDujWMU9KtPoFQChQyW3Nw%2BdSYHUdvNKiqRPmwoTsU0Wbu808oi0AzNvY4mDvHTx5wu9gIAgATbDHAAVNzSJUDdsdizF3t64netxYbntJvwxDHBApJgGAGdZr7usV8ayRVQrM6J8n9pjQGCPWNYK6NynC1YgS/jl3zWcVznB5kuJ1mdrWOFNgyP7iqp/kPgZmJu/ejI8sZlavlpH5flWzafgyVnUp89Jdm3AVGd5nLUgyTb8XbnFxvdiV4FQRdd83bwIxOYsaIer0arJGIPCXc5hbJmCJOgDUbgGDgM7qTJubAW7YFlhzIOI5qhKDhO/CAn9kHf1FucMW6pNT4MwCgtBuonibkwEOW2L8tZvyLqQiw5DKFS3zGQxB3dKGI1Rk2XKxxS5iwHpXHmeseKajEUPPmQJhqCMxJLH6DDAFa2ODI%2BmEBWHsO/pw3KvFdGt34WjXK9dGEDSxmo0chVKaYNoEoO61ivYWx9urXOj8RxWLsd43xXxHosCYGEQ2Z1GGPTgXnRMChRAMDAYkcwUD4F9wYOYkKBci6PTwMJJs044RNV7hEmceB26WFUXY9qJZk6oBYCuIgK4GACHVJEkc0TDBxIgYkyB0CulJJilUmpfc6nJMaak8pSZWH9OoQLBASJoggijBAIgoyBqsKIFMuisz5nUGINU5ZmMlZ2LdhALgeyom42NMXRIwIfjqhWFNAqHBVi0E4ESXgfgOBaFIKgTg9IH5gnWJsBaZhdg8FIAQTQjzVhRhAESDQTxDJmC5BhSQNZYVMi4PoTgkg3kQq%2BZwXgCgQBrnBR8x5pA4CwCQGgE0dA4jkEoNS5ItL4jAC4FwJINBaBGmIISiA0RcWXGYMQK0nBQXUrYIIAA8tTEVpLSBYECUYcQcr8ApW6HKQlcrMCqC6F4I0oreDwmqLi0i0QbrCo8FgXFBAQEsANasKgBhgAKAAGp4EwAAd0lctA1MhBAiDEOwKQfr5BKDULi3QGKDBGBQCUmwprCWQFWL1WoMJ8VVBqJkFwDB3CeFaAkIkQQc0DFKOUCQZhAipHSKmyYfhIH5GrZkEtQx4jso6NUeUPRZi1oLRmztdRZjNsWK2itMw%2Bg9vrWMPoQ6y1ttWAoAFWw9A2swNsHgTyXk4rld8jgqgnLDX8JIY4wBkCIzZU8MwRdfl8RsIifACoCQgpXB4Gl9BC57BObwElWgDykGhZIGkTx2hcjMBoDQRJ2UAa4BhQtzyODYtIHargYHSDvM%2BTuglRKwUQt/XBswW70Ppu/ZC0gcoeVZskEAA">汇编</a>吧。</p>
<p><img src="/img/%E9%9D%9E%E9%80%92%E5%BD%92dfs/ce_inline.png" alt="debug 的汇编"></p>
<p>左边和右边被我圈出来的是互相对应的代码段，乍一看这好像也没什么问题，函数在汇编里被正确调用了。</p>
<p>可是我明明在写这些函数的时候加了 inline<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="在 C/C++ 中，为了解决一些频繁调用的小函数大量消耗栈空间（栈内存）的问题，特别的引入了 inline 修饰符，表示为内联函数。（相当于把函数内的内容直接放到调用的地方了，免去了函数调用的繁琐过程）。[来源](https://www.runoob.com/w3cnote/cpp-inline-usage.html)">[3]</span></a></sup> 啊（如下图）。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">inline</span> FRAME_TYPE<span class="token operator">&amp;</span> <span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span>         <span class="token punctuation">&#123;</span><span class="token keyword">return</span> stk<span class="token punctuation">[</span>sp<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>
<span class="token keyword">inline</span> <span class="token keyword">bool</span> <span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span>              <span class="token punctuation">&#123;</span><span class="token keyword">return</span> sp <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>如果说 inline 没起作用的话，那化简掉的函数调用在这里就还回来了，甚至还增加了函数调用。</p>
<p>这也提醒了我们，inline 关键字只是建议编译器把函数改成内联函数，如果编译器觉得函数比较复杂，是可以不内联的。（但是这函数真的超级简单啊，为什么不内联。。。）</p>
<p>所以我把这些内联函数全部换成了宏定义，这样就是真正的“内联”了，效果如下：</p>
<table>
<thead>
<tr>
<th>时间（s）</th>
<th>空间（MB）</th>
</tr>
</thead>
<tbody>
<tr>
<td>8.83</td>
<td>63.16</td>
</tr>
</tbody>
</table>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/record/74546789">提交记录</a><br>
提升了 0.2 秒左右。<s>不过为了这 0.2 秒多写几十行代码就。。。</s></p>
<h3 id="2-3-4：骚操作">2.3.4：骚操作</h3>
<h4 id="2-3-4-1：一次返回多层函数">2.3.4.1：一次返回多层函数</h4>
<p>我们知道在常规的 dfs（或是其他递归函数）中，<code>return</code> 一次，只会返回到调用这个函数的函数。这是因为执行一次 <code>return</code> 会弹出一个栈帧。但既然我们能通过模拟栈帧的方法，完全把函数调用的过程掌握在我们自己的手中，为什么不能一次弹出多个栈帧呢？虽然听起来挺离谱的，但是也许在某些时候会有些用处。</p>
<p>比如，如果我们想通过递归来暴搜出某一个答案，现在在某一层递归中，答案已经找到了。正常情况下，我们需要一层一层的退出递归调用。而使用模拟栈帧的方法，我们可以直接把前面所有的栈帧都弹出，或者更直接一点，直接从模拟栈帧的循环中 <code>break</code>出来。</p>
<p>为了测试这个骚操作对性能的提升，我又在洛谷上传了一道题目。题目大概是给你一个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5000</mn><mo>×</mo><mn>5000</mn></mrow><annotation encoding="application/x-tex">5000 \times 5000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">5000</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">5000</span></span></span></span> 的网格，每个格子都可以是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 或是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>，分别表示不可以走和可以走，问你能否从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(1, 1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> ，通过八个方向的移动，到达 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x, y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>。并且，在搜索的过程中，需要按照 dfs 的顺序输出访问的位置。</p>
<p>输入数据生成器如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;bits/stdc++.h></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">float</span> valid_possiblity <span class="token operator">=</span> <span class="token number">0.7</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> MAXN <span class="token operator">=</span> <span class="token number">5000</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> _ <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> _ <span class="token operator">&lt;=</span> <span class="token number">10</span><span class="token punctuation">;</span> _<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        string f_name <span class="token operator">=</span> <span class="token string">"test"</span> <span class="token operator">+</span> <span class="token function">to_string</span><span class="token punctuation">(</span>_<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">freopen</span><span class="token punctuation">(</span><span class="token punctuation">(</span>f_name <span class="token operator">+</span> <span class="token string">".in"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"w"</span><span class="token punctuation">,</span> <span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d %d\n"</span><span class="token punctuation">,</span> MAXN<span class="token punctuation">,</span> MAXN<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// int endx = rand() % MAXN;</span>
        <span class="token comment">// int endy = rand() % MAXN;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d %d\n"</span><span class="token punctuation">,</span> MAXN<span class="token punctuation">,</span> MAXN<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> MAXN<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> MAXN<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> j <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">||</span> i <span class="token operator">==</span> MAXN <span class="token operator">&amp;&amp;</span> j <span class="token operator">==</span> MAXN<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
                    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"1 "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">continue</span><span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">(</span><span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token keyword">double</span><span class="token punctuation">(</span>RAND_MAX<span class="token punctuation">)</span> <span class="token operator">*</span> valid_possiblity<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
                    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"1 "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span>
                <span class="token keyword">else</span><span class="token punctuation">&#123;</span>
                    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"0 "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span>
            <span class="token punctuation">&#125;</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果使用的非递归的 dfs，在发现能够到达 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x, y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span> 点之后就可以立刻退出搜索，而正常的 dfs 会需要一层一层的退出。</p>
<p>所以，也许非递归的 dfs 会快一点？</p>
<p>具体的结果可以见下表:</p>
<table>
<thead>
<tr>
<th></th>
<th>常规 dfs</th>
<th>非递归 dfs+数组模拟栈</th>
<th>非递归 dfs+stl stack</th>
</tr>
</thead>
<tbody>
<tr>
<td>提交记录</td>
<td><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/record/74590998">记录</a></td>
<td><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/record/74742271">记录</a></td>
<td><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/record/74742233">记录</a></td>
</tr>
<tr>
<td>时间（s）</td>
<td>7.77</td>
<td>9.53</td>
<td>10.50（时间超限）</td>
</tr>
<tr>
<td>空间（MB）</td>
<td>512+（内存超限）</td>
<td>335.54</td>
<td>187.01</td>
</tr>
</tbody>
</table>
<p>结果还是挺出乎我意料的。在最后一个点中，常规 dfs 因为内存超限被卡掉了，但是前面的点中，常规 dfs 都比非递归的快，不管是用数组模拟栈的还是使用 stl stack 的。</p>
<p>对比 stl stack 的非递归 dfs 和常规 dfs，可以发现在这个问题中，使用非递归 dfs 对节省内存有比较显著的作用。（至于为什么用数组模拟的内存占用看起来很大，已经在前面解释过了）。</p>
<p>不过这些测试还是不能较好的展现逐层返回和直接返回的区别，所以我使用了 chrono 库（精度比 <code>clock()</code> 更高，可以获取纳秒级别的时间）来测量函数返回的时间占用。</p>
<p>结果就比较一言难尽了，高情商的说法是直接返回的返回速度比逐层返回快了约 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>500</mn></mrow><annotation encoding="application/x-tex">500</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">500</span></span></span></span> 倍，低情商的说法是逐层返回的时间占用也就 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>50000</mn></mrow><annotation encoding="application/x-tex">50000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">50000</span></span></span></span> 纳秒 （<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0.05</mn></mrow><annotation encoding="application/x-tex">0.05</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0.05</span></span></span></span> 毫秒）。当然，函数的返回速度也跟返回值类型有关，每次传递返回值都需要一定的时间，如果递归的层数特别多，并且返回值类型非常大，使用直接返回也许就能产生显著的效果了（<s>这样的情况似乎基本上没有呢</s>）。</p>
<h4 id="2-3-4-2：获取调用者的局部变量以及其他骚操作">2.3.4.2：获取调用者的局部变量以及其他骚操作</h4>
<p>这个骚操作已经在前面小优化的部分提到过了，因为所有函数的栈帧都储存在一个栈里，如果你用的是数组模拟栈，那就可以访问到之前被调用的函数的局部变量。在一些场景中，比如之前讲到的树的 dfs 遍历，就可以用到这个方法节省空间。至于别的用途我还真没想到，如果你有想法的话欢迎在评论区分享。</p>
<p>此外，就像是我们能弹出任意数量的栈帧一样，如果你愿意，用模拟栈帧的方法，你还可以在一个函数中同时调用任意数量的函数，也就是压入任意数量的栈帧。<s>当然我也没想出来如何利用这种阴间操作。</s></p>
<h2 id="2-4：总结">2.4：总结</h2>
<p>总的来说，非递归 dfs 的教学意义是大于实际意义的。虽然有的时候非递归 dfs 可以带来一些常数提升，但是会需要更多的时间写出非递归 dfs。而且这一点微弱的常数提升在 O2 的加持下也变的没有意义了。除非一个题目非常的卡常，还不能使用 bfs 和 O2，不然最好还是不要写这种奇怪的东西。</p>
<p>所有非递归 dfs 能带来的优化是建立在递归这种特殊的函数调用的基础上的。在递归中，每次函数调用的栈帧都有着相同的结构，相同的大小，所以我们才能使用结构体把栈帧封装起来，并简化函数调用的过程。</p>
<p>之前提到的骚操作也是因为我们对函数调用有了完全的控制，可以随意访问栈中的内存，并且弹出和压入任意数量的栈帧。如果函数调用不是在递归中的，那我们就不知道每个栈帧的长度和结构，自然也没法实现这样的操作。</p>
<p>最后，如果你有问题或是建议，都欢迎在评论区分享或者是联系我。</p>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">来源为：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/zzdbullet/p/9629909.html">https://www.cnblogs.com/zzdbullet/p/9629909.html</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">pc 即 program counter, 程序计数器，它指向下一条指令所在的内存单元的地址，通过 pc，计算机总是可以知道下一步该干什么。<a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">在 C/C++ 中，为了解决一些频繁调用的小函数大量消耗栈空间（栈内存）的问题，特别的引入了 inline 修饰符，表示为内联函数。（相当于把函数内的内容直接放到调用的地方了，免去了函数调用的繁琐过程）。<a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/cpp-inline-usage.html">来源</a><a href="#fnref:3" rev="footnote"> ↩</a></span></li></ol></div></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">tzyt</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://ttzytt.com/2022/04/function-call/">https://ttzytt.com/2022/04/function-call/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://ttzytt.com" target="_blank">tzyt的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/2022/">2022</a><a class="post-meta__tags" href="/tags/%E6%B1%87%E7%BC%96/">汇编</a><a class="post-meta__tags" href="/tags/%E5%BA%95%E5%B1%82/">底层</a><a class="post-meta__tags" href="/tags/%E6%A0%88%E5%B8%A7/">栈帧</a><a class="post-meta__tags" href="/tags/dfs/">dfs</a><a class="post-meta__tags" href="/tags/%E6%95%B4%E6%B4%BB/">整活</a></div><div class="post_share"><div class="social-share" data-image="/img/%E9%9D%9E%E9%80%92%E5%BD%92dfs/cover.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/06/CF1665C/"><img class="prev-cover" src="/img/Codeforces_logo.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">CF1665C题解</div></div></a></div><div class="next-post pull-right"><a href="/2022/04/P8270/"><img class="next-cover" src="/img/USACO_logo.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">洛谷 P8270 [USACO22OPEN] Subset Equality S 题解</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/06/CF1665C/" title="CF1665C题解"><img class="cover" src="/img/Codeforces_logo.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-13</div><div class="title">CF1665C题解</div></div></a></div><div><a href="/2022/06/CF1692G/" title="CF1692G题解"><img class="cover" src="/img/Codeforces_logo.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-16</div><div class="title">CF1692G题解</div></div></a></div><div><a href="/2022/03/P8187/" title="P8187 [USACO22FEB] Robot Instructions S 题解"><img class="cover" src="/img/USACO_logo.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-14</div><div class="title">P8187 [USACO22FEB] Robot Instructions S 题解</div></div></a></div><div><a href="/2022/02/P8095/" title="P8095 [USACO22JAN] Cereal 2 S题解"><img class="cover" src="https://cdn.luogu.com.cn/upload/image_hosting/63og5ij1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-06</div><div class="title">P8095 [USACO22JAN] Cereal 2 S题解</div></div></a></div><div><a href="/2022/04/P8269/" title="P8269 [USACO22OPEN] Visits S 题解"><img class="cover" src="https://cdn.luogu.com.cn/upload/image_hosting/45pac1tr.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-08</div><div class="title">P8269 [USACO22OPEN] Visits S 题解</div></div></a></div><div><a href="/2022/04/P8270/" title="洛谷 P8270 [USACO22OPEN] Subset Equality S 题解"><img class="cover" src="/img/USACO_logo.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-10</div><div class="title">洛谷 P8270 [USACO22OPEN] Subset Equality S 题解</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.gif" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">tzyt</div><div class="author-info__description"></div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">13</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">35</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://www.luogu.com.cn/user/394488"><i class="fa-solid fa-up-right-from-square"></i><span>洛谷</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/ttzytt" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="/Zyt2006613@outlook.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS链接"><i class="fa fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">如果有想交换友链的，可以通过洛谷的私信，我的邮箱，或者是右下角那个聊天室联系我。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">1：函数调用是如何实现的？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1%EF%BC%9A%E4%B8%80%E4%B8%AA%E5%B0%8F%E4%BE%8B%E5%AD%90"><span class="toc-text">1.1：一个小例子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2%EF%BC%9A%E6%A0%88%E5%B8%A7"><span class="toc-text">1.2：栈帧</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-1%EF%BC%9A%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="toc-text">1.2.1：基本结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-2%EF%BC%9A%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0%E6%97%B6%E6%A0%88%E5%B8%A7%E7%9A%84%E5%8F%98%E5%8C%96"><span class="toc-text">1.2.2：调用函数时栈帧的变化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-3%EF%BC%9A%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E6%97%B6%E6%A0%88%E5%B8%A7%E7%9A%84%E5%8F%98%E5%8C%96"><span class="toc-text">1.2.3：函数返回时栈帧的变化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-4%EF%BC%9A%E8%A7%86%E9%A2%91%E8%A7%A3%E9%87%8A"><span class="toc-text">1.2.4：视频解释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-5%EF%BC%9ATalk-is-cheap-Show-me-the-code"><span class="toc-text">1.2.5：Talk is cheap. Show me the code.</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-5-1%EF%BC%9A%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81"><span class="toc-text">1.2.5.1：如何查看汇编代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-5-2%EF%BC%9ACompiler-Explorer-%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-text">1.2.5.2：Compiler Explorer 的基本介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-5-3%EF%BC%9A%E5%88%86%E6%9E%90%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%9A%84%E6%B1%87%E7%BC%96"><span class="toc-text">1.2.5.3：分析函数调用的汇编</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3%EF%BC%9A%E4%B8%8D%E5%90%8C%E7%9A%84%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A-%EF%BC%88calling-convention%EF%BC%89"><span class="toc-text">1.3：不同的函数调用约定 （calling convention）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-1%EF%BC%9Ax86%EF%BC%8832%E4%BD%8D%E6%9C%BA%EF%BC%89%E7%9A%84%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A"><span class="toc-text">1.3.1：x86（32位机）的函数调用约定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-2%EF%BC%9Ax64%EF%BC%8864%E4%BD%8D%E6%9C%BA%EF%BC%89%E7%9A%84%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A"><span class="toc-text">1.3.2：x64（64位机）的函数调用约定</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">2：如何写一个不用递归的 dfs 来遍历树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1%EF%BC%9A%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="toc-text">2.1：具体实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2%EF%BC%9A%E5%B0%8F%E4%BC%98%E5%8C%96"><span class="toc-text">2.2：小优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3%EF%BC%9A%E6%89%80%E4%BB%A5%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F%EF%BC%9F"><span class="toc-text">2.3：所以，有什么用？？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-1%EF%BC%9A%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95"><span class="toc-text">2.3.1：测试方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-2%EF%BC%9A%E7%A9%BA%E9%97%B4%EF%BC%9F"><span class="toc-text">2.3.2：空间？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-3%EF%BC%9A%E6%97%B6%E9%97%B4%EF%BC%9F"><span class="toc-text">2.3.3：时间？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-4%EF%BC%9A%E9%AA%9A%E6%93%8D%E4%BD%9C"><span class="toc-text">2.3.4：骚操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-4-1%EF%BC%9A%E4%B8%80%E6%AC%A1%E8%BF%94%E5%9B%9E%E5%A4%9A%E5%B1%82%E5%87%BD%E6%95%B0"><span class="toc-text">2.3.4.1：一次返回多层函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-4-2%EF%BC%9A%E8%8E%B7%E5%8F%96%E8%B0%83%E7%94%A8%E8%80%85%E7%9A%84%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E4%BB%A5%E5%8F%8A%E5%85%B6%E4%BB%96%E9%AA%9A%E6%93%8D%E4%BD%9C"><span class="toc-text">2.3.4.2：获取调用者的局部变量以及其他骚操作</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4%EF%BC%9A%E6%80%BB%E7%BB%93"><span class="toc-text">2.4：总结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/06/CF1692G/" title="CF1692G题解"><img src="/img/Codeforces_logo.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CF1692G题解"/></a><div class="content"><a class="title" href="/2022/06/CF1692G/" title="CF1692G题解">CF1692G题解</a><time datetime="2022-06-17T03:50:12.693Z" title="发表于 2022-06-16 23:50:12">2022-06-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/06/hexo_font_update/" title="Hexo Butterfly 更换字体时遇到的一些奇怪的问题"><img src="/img/Hexo_blog_logo.svg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hexo Butterfly 更换字体时遇到的一些奇怪的问题"/></a><div class="content"><a class="title" href="/2022/06/hexo_font_update/" title="Hexo Butterfly 更换字体时遇到的一些奇怪的问题">Hexo Butterfly 更换字体时遇到的一些奇怪的问题</a><time datetime="2022-06-14T23:18:55.952Z" title="发表于 2022-06-14 19:18:55">2022-06-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/06/treap_note/" title="Treap（树堆）学习笔记，基于洛谷 P3369"><img src="/img/treap/rotate.svg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Treap（树堆）学习笔记，基于洛谷 P3369"/></a><div class="content"><a class="title" href="/2022/06/treap_note/" title="Treap（树堆）学习笔记，基于洛谷 P3369">Treap（树堆）学习笔记，基于洛谷 P3369</a><time datetime="2022-06-14T02:56:57.266Z" title="发表于 2022-06-13 22:56:57">2022-06-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/06/CF1665C/" title="CF1665C题解"><img src="/img/Codeforces_logo.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CF1665C题解"/></a><div class="content"><a class="title" href="/2022/06/CF1665C/" title="CF1665C题解">CF1665C题解</a><time datetime="2022-06-13T21:04:20.376Z" title="发表于 2022-06-13 17:04:20">2022-06-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/function-call/" title="浅谈函数调用的实现"><img src="/img/%E9%9D%9E%E9%80%92%E5%BD%92dfs/cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="浅谈函数调用的实现"/></a><div class="content"><a class="title" href="/2022/04/function-call/" title="浅谈函数调用的实现">浅谈函数调用的实现</a><time datetime="2022-04-21T03:53:01.966Z" title="发表于 2022-04-20 23:53:01">2022-04-20</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 By tzyt</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Algolia</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/contrib/copy-tex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/contrib/copy-tex.css"><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script><script>function loadWaline () {
  function initWaline () {
    const waline = new Waline(Object.assign({
      el: '#waline-wrap',
      serverURL: 'https://waline-comment-for-hexo-blog-pi6qofxob-ttzytt.vercel.app/',
      path: location.pathname,
      visitor: true,
      dark: 'html[data-theme="dark"]'
    }, null))
  }

  if (typeof Waline === 'function') initWaline()
  else getScript('https://cdn.jsdelivr.net/npm/@waline/client/dist/Waline.min.js').then(initWaline)
}

if ('Waline' === 'Waline' || !false) {
  if (false) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
  else setTimeout(loadWaline, 0)
} else {
  function loadOtherComment () {
    loadWaline()
  }
}</script></div><script src="/js/gitter_chat.js"></script><script src="https://sidecar.gitter.im/dist/sidecar.v1.js" async defer></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="100,100,100" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>